import {
  require_eventemitter3
} from "./chunk-57BKVESE.js";
import {
  require_react_dom
} from "./chunk-WXXXOI4T.js";
import {
  require_react
} from "./chunk-IXSHOAML.js";
import {
  Contract,
  init_lib,
  init_lib10,
  init_lib11,
  init_lib12,
  init_lib13,
  init_lib14,
  init_lib15,
  init_lib16,
  init_lib17,
  init_lib18,
  init_lib19,
  init_lib2,
  init_lib20,
  init_lib21,
  init_lib22,
  init_lib23,
  init_lib24,
  init_lib25,
  init_lib26,
  init_lib27,
  init_lib3,
  init_lib4,
  init_lib5,
  init_lib6,
  init_lib7,
  init_lib8,
  init_lib9,
  lib_exports,
  lib_exports10,
  lib_exports11,
  lib_exports12,
  lib_exports13,
  lib_exports14,
  lib_exports15,
  lib_exports16,
  lib_exports17,
  lib_exports18,
  lib_exports19,
  lib_exports2,
  lib_exports20,
  lib_exports21,
  lib_exports22,
  lib_exports23,
  lib_exports24,
  lib_exports25,
  lib_exports26,
  lib_exports27,
  lib_exports3,
  lib_exports4,
  lib_exports5,
  lib_exports6,
  lib_exports7,
  lib_exports8,
  lib_exports9
} from "./chunk-VNDBLEQY.js";
import {
  __commonJS,
  __toCommonJS,
  __toESM
} from "./chunk-7TBCKYSC.js";

// node_modules/ethers/lib/utils.js
var require_utils = __commonJS({
  "node_modules/ethers/lib/utils.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatBytes32String = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = exports.nameprep = exports.hexDataSlice = exports.hexDataLength = exports.hexZeroPad = exports.hexValue = exports.hexStripZeros = exports.hexConcat = exports.isHexString = exports.hexlify = exports.base64 = exports.base58 = exports.TransactionDescription = exports.LogDescription = exports.Interface = exports.SigningKey = exports.HDNode = exports.defaultPath = exports.isBytesLike = exports.isBytes = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.shallowCopy = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = exports.deepCopy = exports.checkProperties = exports.poll = exports.fetchJson = exports._fetchData = exports.RLP = exports.Logger = exports.checkResultErrors = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.Fragment = exports.defaultAbiCoder = exports.AbiCoder = void 0;
    exports.Indexed = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = exports.SupportedAlgorithm = exports.mnemonicToSeed = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.getAccountPath = exports.verifyTypedData = exports.verifyMessage = exports.recoverPublicKey = exports.computePublicKey = exports.recoverAddress = exports.computeAddress = exports.getJsonWalletAddress = exports.TransactionTypes = exports.serializeTransaction = exports.parseTransaction = exports.accessListify = exports.joinSignature = exports.splitSignature = exports.soliditySha256 = exports.solidityKeccak256 = exports.solidityPack = exports.shuffled = exports.randomBytes = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.computeHmac = exports.commify = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.isAddress = exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.getAddress = exports._TypedDataEncoder = exports.id = exports.isValidName = exports.namehash = exports.hashMessage = exports.dnsEncode = exports.parseBytes32String = void 0;
    var abi_1 = (init_lib11(), __toCommonJS(lib_exports11));
    Object.defineProperty(exports, "AbiCoder", { enumerable: true, get: function() {
      return abi_1.AbiCoder;
    } });
    Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
      return abi_1.checkResultErrors;
    } });
    Object.defineProperty(exports, "ConstructorFragment", { enumerable: true, get: function() {
      return abi_1.ConstructorFragment;
    } });
    Object.defineProperty(exports, "defaultAbiCoder", { enumerable: true, get: function() {
      return abi_1.defaultAbiCoder;
    } });
    Object.defineProperty(exports, "ErrorFragment", { enumerable: true, get: function() {
      return abi_1.ErrorFragment;
    } });
    Object.defineProperty(exports, "EventFragment", { enumerable: true, get: function() {
      return abi_1.EventFragment;
    } });
    Object.defineProperty(exports, "FormatTypes", { enumerable: true, get: function() {
      return abi_1.FormatTypes;
    } });
    Object.defineProperty(exports, "Fragment", { enumerable: true, get: function() {
      return abi_1.Fragment;
    } });
    Object.defineProperty(exports, "FunctionFragment", { enumerable: true, get: function() {
      return abi_1.FunctionFragment;
    } });
    Object.defineProperty(exports, "Indexed", { enumerable: true, get: function() {
      return abi_1.Indexed;
    } });
    Object.defineProperty(exports, "Interface", { enumerable: true, get: function() {
      return abi_1.Interface;
    } });
    Object.defineProperty(exports, "LogDescription", { enumerable: true, get: function() {
      return abi_1.LogDescription;
    } });
    Object.defineProperty(exports, "ParamType", { enumerable: true, get: function() {
      return abi_1.ParamType;
    } });
    Object.defineProperty(exports, "TransactionDescription", { enumerable: true, get: function() {
      return abi_1.TransactionDescription;
    } });
    var address_1 = (init_lib7(), __toCommonJS(lib_exports7));
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return address_1.getAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return address_1.getCreate2Address;
    } });
    Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
      return address_1.getContractAddress;
    } });
    Object.defineProperty(exports, "getIcapAddress", { enumerable: true, get: function() {
      return address_1.getIcapAddress;
    } });
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return address_1.isAddress;
    } });
    var base64 = __importStar((init_lib23(), __toCommonJS(lib_exports23)));
    exports.base64 = base64;
    var basex_1 = (init_lib16(), __toCommonJS(lib_exports16));
    Object.defineProperty(exports, "base58", { enumerable: true, get: function() {
      return basex_1.Base58;
    } });
    var bytes_1 = (init_lib2(), __toCommonJS(lib_exports2));
    Object.defineProperty(exports, "arrayify", { enumerable: true, get: function() {
      return bytes_1.arrayify;
    } });
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return bytes_1.concat;
    } });
    Object.defineProperty(exports, "hexConcat", { enumerable: true, get: function() {
      return bytes_1.hexConcat;
    } });
    Object.defineProperty(exports, "hexDataSlice", { enumerable: true, get: function() {
      return bytes_1.hexDataSlice;
    } });
    Object.defineProperty(exports, "hexDataLength", { enumerable: true, get: function() {
      return bytes_1.hexDataLength;
    } });
    Object.defineProperty(exports, "hexlify", { enumerable: true, get: function() {
      return bytes_1.hexlify;
    } });
    Object.defineProperty(exports, "hexStripZeros", { enumerable: true, get: function() {
      return bytes_1.hexStripZeros;
    } });
    Object.defineProperty(exports, "hexValue", { enumerable: true, get: function() {
      return bytes_1.hexValue;
    } });
    Object.defineProperty(exports, "hexZeroPad", { enumerable: true, get: function() {
      return bytes_1.hexZeroPad;
    } });
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return bytes_1.isBytes;
    } });
    Object.defineProperty(exports, "isBytesLike", { enumerable: true, get: function() {
      return bytes_1.isBytesLike;
    } });
    Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
      return bytes_1.isHexString;
    } });
    Object.defineProperty(exports, "joinSignature", { enumerable: true, get: function() {
      return bytes_1.joinSignature;
    } });
    Object.defineProperty(exports, "zeroPad", { enumerable: true, get: function() {
      return bytes_1.zeroPad;
    } });
    Object.defineProperty(exports, "splitSignature", { enumerable: true, get: function() {
      return bytes_1.splitSignature;
    } });
    Object.defineProperty(exports, "stripZeros", { enumerable: true, get: function() {
      return bytes_1.stripZeros;
    } });
    var hash_1 = (init_lib10(), __toCommonJS(lib_exports10));
    Object.defineProperty(exports, "_TypedDataEncoder", { enumerable: true, get: function() {
      return hash_1._TypedDataEncoder;
    } });
    Object.defineProperty(exports, "dnsEncode", { enumerable: true, get: function() {
      return hash_1.dnsEncode;
    } });
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return hash_1.hashMessage;
    } });
    Object.defineProperty(exports, "id", { enumerable: true, get: function() {
      return hash_1.id;
    } });
    Object.defineProperty(exports, "isValidName", { enumerable: true, get: function() {
      return hash_1.isValidName;
    } });
    Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
      return hash_1.namehash;
    } });
    var hdnode_1 = (init_lib19(), __toCommonJS(lib_exports19));
    Object.defineProperty(exports, "defaultPath", { enumerable: true, get: function() {
      return hdnode_1.defaultPath;
    } });
    Object.defineProperty(exports, "entropyToMnemonic", { enumerable: true, get: function() {
      return hdnode_1.entropyToMnemonic;
    } });
    Object.defineProperty(exports, "getAccountPath", { enumerable: true, get: function() {
      return hdnode_1.getAccountPath;
    } });
    Object.defineProperty(exports, "HDNode", { enumerable: true, get: function() {
      return hdnode_1.HDNode;
    } });
    Object.defineProperty(exports, "isValidMnemonic", { enumerable: true, get: function() {
      return hdnode_1.isValidMnemonic;
    } });
    Object.defineProperty(exports, "mnemonicToEntropy", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToEntropy;
    } });
    Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToSeed;
    } });
    var json_wallets_1 = (init_lib21(), __toCommonJS(lib_exports21));
    Object.defineProperty(exports, "getJsonWalletAddress", { enumerable: true, get: function() {
      return json_wallets_1.getJsonWalletAddress;
    } });
    var keccak256_1 = (init_lib5(), __toCommonJS(lib_exports5));
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak256_1.keccak256;
    } });
    var logger_1 = (init_lib(), __toCommonJS(lib_exports));
    Object.defineProperty(exports, "Logger", { enumerable: true, get: function() {
      return logger_1.Logger;
    } });
    var sha2_1 = (init_lib17(), __toCommonJS(lib_exports17));
    Object.defineProperty(exports, "computeHmac", { enumerable: true, get: function() {
      return sha2_1.computeHmac;
    } });
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return sha2_1.ripemd160;
    } });
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha2_1.sha256;
    } });
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha2_1.sha512;
    } });
    var solidity_1 = (init_lib26(), __toCommonJS(lib_exports26));
    Object.defineProperty(exports, "solidityKeccak256", { enumerable: true, get: function() {
      return solidity_1.keccak256;
    } });
    Object.defineProperty(exports, "solidityPack", { enumerable: true, get: function() {
      return solidity_1.pack;
    } });
    Object.defineProperty(exports, "soliditySha256", { enumerable: true, get: function() {
      return solidity_1.sha256;
    } });
    var random_1 = (init_lib20(), __toCommonJS(lib_exports20));
    Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
      return random_1.randomBytes;
    } });
    Object.defineProperty(exports, "shuffled", { enumerable: true, get: function() {
      return random_1.shuffled;
    } });
    var properties_1 = (init_lib4(), __toCommonJS(lib_exports4));
    Object.defineProperty(exports, "checkProperties", { enumerable: true, get: function() {
      return properties_1.checkProperties;
    } });
    Object.defineProperty(exports, "deepCopy", { enumerable: true, get: function() {
      return properties_1.deepCopy;
    } });
    Object.defineProperty(exports, "defineReadOnly", { enumerable: true, get: function() {
      return properties_1.defineReadOnly;
    } });
    Object.defineProperty(exports, "getStatic", { enumerable: true, get: function() {
      return properties_1.getStatic;
    } });
    Object.defineProperty(exports, "resolveProperties", { enumerable: true, get: function() {
      return properties_1.resolveProperties;
    } });
    Object.defineProperty(exports, "shallowCopy", { enumerable: true, get: function() {
      return properties_1.shallowCopy;
    } });
    var RLP = __importStar((init_lib6(), __toCommonJS(lib_exports6)));
    exports.RLP = RLP;
    var signing_key_1 = (init_lib13(), __toCommonJS(lib_exports13));
    Object.defineProperty(exports, "computePublicKey", { enumerable: true, get: function() {
      return signing_key_1.computePublicKey;
    } });
    Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
      return signing_key_1.recoverPublicKey;
    } });
    Object.defineProperty(exports, "SigningKey", { enumerable: true, get: function() {
      return signing_key_1.SigningKey;
    } });
    var strings_1 = (init_lib9(), __toCommonJS(lib_exports9));
    Object.defineProperty(exports, "formatBytes32String", { enumerable: true, get: function() {
      return strings_1.formatBytes32String;
    } });
    Object.defineProperty(exports, "nameprep", { enumerable: true, get: function() {
      return strings_1.nameprep;
    } });
    Object.defineProperty(exports, "parseBytes32String", { enumerable: true, get: function() {
      return strings_1.parseBytes32String;
    } });
    Object.defineProperty(exports, "_toEscapedUtf8String", { enumerable: true, get: function() {
      return strings_1._toEscapedUtf8String;
    } });
    Object.defineProperty(exports, "toUtf8Bytes", { enumerable: true, get: function() {
      return strings_1.toUtf8Bytes;
    } });
    Object.defineProperty(exports, "toUtf8CodePoints", { enumerable: true, get: function() {
      return strings_1.toUtf8CodePoints;
    } });
    Object.defineProperty(exports, "toUtf8String", { enumerable: true, get: function() {
      return strings_1.toUtf8String;
    } });
    Object.defineProperty(exports, "Utf8ErrorFuncs", { enumerable: true, get: function() {
      return strings_1.Utf8ErrorFuncs;
    } });
    var transactions_1 = (init_lib14(), __toCommonJS(lib_exports14));
    Object.defineProperty(exports, "accessListify", { enumerable: true, get: function() {
      return transactions_1.accessListify;
    } });
    Object.defineProperty(exports, "computeAddress", { enumerable: true, get: function() {
      return transactions_1.computeAddress;
    } });
    Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
      return transactions_1.parse;
    } });
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return transactions_1.recoverAddress;
    } });
    Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
      return transactions_1.serialize;
    } });
    Object.defineProperty(exports, "TransactionTypes", { enumerable: true, get: function() {
      return transactions_1.TransactionTypes;
    } });
    var units_1 = (init_lib27(), __toCommonJS(lib_exports27));
    Object.defineProperty(exports, "commify", { enumerable: true, get: function() {
      return units_1.commify;
    } });
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return units_1.formatEther;
    } });
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return units_1.parseEther;
    } });
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return units_1.formatUnits;
    } });
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return units_1.parseUnits;
    } });
    var wallet_1 = (init_lib22(), __toCommonJS(lib_exports22));
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return wallet_1.verifyMessage;
    } });
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return wallet_1.verifyTypedData;
    } });
    var web_1 = (init_lib24(), __toCommonJS(lib_exports24));
    Object.defineProperty(exports, "_fetchData", { enumerable: true, get: function() {
      return web_1._fetchData;
    } });
    Object.defineProperty(exports, "fetchJson", { enumerable: true, get: function() {
      return web_1.fetchJson;
    } });
    Object.defineProperty(exports, "poll", { enumerable: true, get: function() {
      return web_1.poll;
    } });
    var sha2_2 = (init_lib17(), __toCommonJS(lib_exports17));
    Object.defineProperty(exports, "SupportedAlgorithm", { enumerable: true, get: function() {
      return sha2_2.SupportedAlgorithm;
    } });
    var strings_2 = (init_lib9(), __toCommonJS(lib_exports9));
    Object.defineProperty(exports, "UnicodeNormalizationForm", { enumerable: true, get: function() {
      return strings_2.UnicodeNormalizationForm;
    } });
    Object.defineProperty(exports, "Utf8ErrorReason", { enumerable: true, get: function() {
      return strings_2.Utf8ErrorReason;
    } });
  }
});

// node_modules/ethers/lib/_version.js
var require_version = __commonJS({
  "node_modules/ethers/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "ethers/5.6.9";
  }
});

// node_modules/ethers/lib/ethers.js
var require_ethers = __commonJS({
  "node_modules/ethers/lib/ethers.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Wordlist = exports.version = exports.wordlists = exports.utils = exports.logger = exports.errors = exports.constants = exports.FixedNumber = exports.BigNumber = exports.ContractFactory = exports.Contract = exports.BaseContract = exports.providers = exports.getDefaultProvider = exports.VoidSigner = exports.Wallet = exports.Signer = void 0;
    var contracts_1 = (init_lib15(), __toCommonJS(lib_exports15));
    Object.defineProperty(exports, "BaseContract", { enumerable: true, get: function() {
      return contracts_1.BaseContract;
    } });
    Object.defineProperty(exports, "Contract", { enumerable: true, get: function() {
      return contracts_1.Contract;
    } });
    Object.defineProperty(exports, "ContractFactory", { enumerable: true, get: function() {
      return contracts_1.ContractFactory;
    } });
    var bignumber_1 = (init_lib3(), __toCommonJS(lib_exports3));
    Object.defineProperty(exports, "BigNumber", { enumerable: true, get: function() {
      return bignumber_1.BigNumber;
    } });
    Object.defineProperty(exports, "FixedNumber", { enumerable: true, get: function() {
      return bignumber_1.FixedNumber;
    } });
    var abstract_signer_1 = (init_lib12(), __toCommonJS(lib_exports12));
    Object.defineProperty(exports, "Signer", { enumerable: true, get: function() {
      return abstract_signer_1.Signer;
    } });
    Object.defineProperty(exports, "VoidSigner", { enumerable: true, get: function() {
      return abstract_signer_1.VoidSigner;
    } });
    var wallet_1 = (init_lib22(), __toCommonJS(lib_exports22));
    Object.defineProperty(exports, "Wallet", { enumerable: true, get: function() {
      return wallet_1.Wallet;
    } });
    var constants = __importStar((init_lib8(), __toCommonJS(lib_exports8)));
    exports.constants = constants;
    var providers = __importStar((init_lib25(), __toCommonJS(lib_exports25)));
    exports.providers = providers;
    var providers_1 = (init_lib25(), __toCommonJS(lib_exports25));
    Object.defineProperty(exports, "getDefaultProvider", { enumerable: true, get: function() {
      return providers_1.getDefaultProvider;
    } });
    var wordlists_1 = (init_lib18(), __toCommonJS(lib_exports18));
    Object.defineProperty(exports, "Wordlist", { enumerable: true, get: function() {
      return wordlists_1.Wordlist;
    } });
    Object.defineProperty(exports, "wordlists", { enumerable: true, get: function() {
      return wordlists_1.wordlists;
    } });
    var utils = __importStar(require_utils());
    exports.utils = utils;
    var logger_1 = (init_lib(), __toCommonJS(lib_exports));
    Object.defineProperty(exports, "errors", { enumerable: true, get: function() {
      return logger_1.ErrorCode;
    } });
    var _version_1 = require_version();
    Object.defineProperty(exports, "version", { enumerable: true, get: function() {
      return _version_1.version;
    } });
    var logger2 = new logger_1.Logger(_version_1.version);
    exports.logger = logger2;
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React12 = require_react();
        var ReactSharedInternals = React12.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useState2 = React12.useState, useEffect2 = React12.useEffect, useLayoutEffect = React12.useLayoutEffect, useDebugValue = React12.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore4(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React12.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState2({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe, value, getSnapshot]);
          useEffect2(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe(handleStoreChange);
          }, [subscribe]);
          useDebugValue(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore4;
        var useSyncExternalStore$2 = React12.useSyncExternalStore !== void 0 ? React12.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React12 = require_react();
        var shim = require_shim();
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useSyncExternalStore4 = shim.useSyncExternalStore;
        var useRef2 = React12.useRef, useEffect2 = React12.useEffect, useMemo2 = React12.useMemo, useDebugValue = React12.useDebugValue;
        function useSyncExternalStoreWithSelector2(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
          var instRef = useRef2(null);
          var inst;
          if (instRef.current === null) {
            inst = {
              hasValue: false,
              value: null
            };
            instRef.current = inst;
          } else {
            inst = instRef.current;
          }
          var _useMemo = useMemo2(function() {
            var hasMemo = false;
            var memoizedSnapshot;
            var memoizedSelection;
            var memoizedSelector = function(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                var _nextSelection = selector(nextSnapshot);
                if (isEqual !== void 0) {
                  if (inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual(currentSelection, _nextSelection)) {
                      memoizedSelection = currentSelection;
                      return currentSelection;
                    }
                  }
                }
                memoizedSelection = _nextSelection;
                return _nextSelection;
              }
              var prevSnapshot = memoizedSnapshot;
              var prevSelection = memoizedSelection;
              if (objectIs(prevSnapshot, nextSnapshot)) {
                return prevSelection;
              }
              var nextSelection = selector(nextSnapshot);
              if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                return prevSelection;
              }
              memoizedSnapshot = nextSnapshot;
              memoizedSelection = nextSelection;
              return nextSelection;
            };
            var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
            var getSnapshotWithSelector = function() {
              return memoizedSelector(getSnapshot());
            };
            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            };
            return [getSnapshotWithSelector, getServerSnapshotWithSelector];
          }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
          var value = useSyncExternalStore4(subscribe, getSelection, getServerSelection);
          useEffect2(function() {
            inst.hasValue = true;
            inst.value = value;
          }, [value]);
          useDebugValue(value);
          return value;
        }
        exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});

// node_modules/@wagmi/core/dist/rpcs-b73a8f60.esm.js
var defaultAlchemyId = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
var alchemyRpcUrls = {
  mainnet: "https://eth-mainnet.alchemyapi.io/v2",
  ropsten: "https://eth-ropsten.alchemyapi.io/v2",
  rinkeby: "https://eth-rinkeby.alchemyapi.io/v2",
  goerli: "https://eth-goerli.alchemyapi.io/v2",
  kovan: "https://eth-kovan.alchemyapi.io/v2",
  optimism: "https://opt-mainnet.g.alchemy.com/v2",
  optimismKovan: "https://opt-kovan.g.alchemy.com/v2",
  polygon: "https://polygon-mainnet.g.alchemy.com/v2",
  polygonMumbai: "https://polygon-mumbai.g.alchemy.com/v2",
  arbitrum: "https://arb-mainnet.g.alchemy.com/v2",
  arbitrumRinkeby: "https://arb-rinkeby.g.alchemy.com/v2"
};
var infuraRpcUrls = {
  mainnet: "https://mainnet.infura.io/v3",
  ropsten: "https://ropsten.infura.io/v3",
  rinkeby: "https://rinkeby.infura.io/v3",
  goerli: "https://goerli.infura.io/v3",
  kovan: "https://kovan.infura.io/v3",
  optimism: "https://optimism-mainnet.infura.io/v3",
  optimismKovan: "https://optimism-kovan.infura.io/v3",
  polygon: "https://polygon-mainnet.infura.io/v3",
  polygonMumbai: "https://polygon-mumbai.infura.io/v3",
  arbitrum: "https://arbitrum-mainnet.infura.io/v3",
  arbitrumRinkeby: "https://arbitrum-rinkeby.infura.io/v3"
};
var publicRpcUrls = {
  mainnet: "".concat(alchemyRpcUrls.mainnet, "/").concat(defaultAlchemyId),
  ropsten: "".concat(alchemyRpcUrls.ropsten, "/").concat(defaultAlchemyId),
  rinkeby: "".concat(alchemyRpcUrls.rinkeby, "/").concat(defaultAlchemyId),
  goerli: "".concat(alchemyRpcUrls.goerli, "/").concat(defaultAlchemyId),
  kovan: "".concat(alchemyRpcUrls.kovan, "/").concat(defaultAlchemyId),
  optimism: "https://mainnet.optimism.io",
  optimismKovan: "https://kovan.optimism.io",
  polygon: "https://polygon-rpc.com",
  polygonMumbai: "https://matic-mumbai.chainstacklabs.com",
  arbitrum: "https://arb1.arbitrum.io/rpc",
  arbitrumRinkeby: "https://rinkeby.arbitrum.io/rpc"
};

// node_modules/@wagmi/core/dist/chains-fd2c546c.esm.js
var etherscanBlockExplorers = {
  mainnet: {
    name: "Etherscan",
    url: "https://etherscan.io"
  },
  ropsten: {
    name: "Etherscan",
    url: "https://ropsten.etherscan.io"
  },
  rinkeby: {
    name: "Etherscan",
    url: "https://rinkeby.etherscan.io"
  },
  goerli: {
    name: "Etherscan",
    url: "https://goerli.etherscan.io"
  },
  kovan: {
    name: "Etherscan",
    url: "https://kovan.etherscan.io"
  },
  optimism: {
    name: "Etherscan",
    url: "https://optimistic.etherscan.io"
  },
  optimismKovan: {
    name: "Etherscan",
    url: "https://kovan-optimistic.etherscan.io"
  },
  polygon: {
    name: "PolygonScan",
    url: "https://polygonscan.com"
  },
  polygonMumbai: {
    name: "PolygonScan",
    url: "https://mumbai.polygonscan.com"
  },
  arbitrum: {
    name: "Arbiscan",
    url: "https://arbiscan.io"
  },
  arbitrumRinkeby: {
    name: "Arbiscan",
    url: "https://testnet.arbiscan.io"
  }
};
var chainId = {
  mainnet: 1,
  ropsten: 3,
  rinkeby: 4,
  goerli: 5,
  kovan: 42,
  optimism: 10,
  optimismKovan: 69,
  polygon: 137,
  polygonMumbai: 80001,
  arbitrum: 42161,
  arbitrumRinkeby: 421611,
  localhost: 1337,
  hardhat: 31337,
  foundry: 31337
};
var mainnet = {
  id: chainId.mainnet,
  name: "Ethereum",
  network: "homestead",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    alchemy: alchemyRpcUrls.mainnet,
    default: publicRpcUrls.mainnet,
    infura: infuraRpcUrls.mainnet,
    public: publicRpcUrls.mainnet
  },
  blockExplorers: {
    etherscan: etherscanBlockExplorers.mainnet,
    default: etherscanBlockExplorers.mainnet
  },
  ens: {
    address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 14353601
  }
};
var ropsten = {
  id: chainId.ropsten,
  name: "Ropsten",
  network: "ropsten",
  nativeCurrency: {
    name: "Ropsten Ether",
    symbol: "ROP",
    decimals: 18
  },
  rpcUrls: {
    alchemy: alchemyRpcUrls.ropsten,
    default: publicRpcUrls.ropsten,
    infura: infuraRpcUrls.ropsten,
    public: publicRpcUrls.ropsten
  },
  blockExplorers: {
    etherscan: etherscanBlockExplorers.ropsten,
    default: etherscanBlockExplorers.ropsten
  },
  ens: {
    address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 12063863
  },
  testnet: true
};
var rinkeby = {
  id: chainId.rinkeby,
  name: "Rinkeby",
  network: "rinkeby",
  nativeCurrency: {
    name: "Rinkeby Ether",
    symbol: "RIN",
    decimals: 18
  },
  rpcUrls: {
    alchemy: alchemyRpcUrls.rinkeby,
    default: publicRpcUrls.rinkeby,
    infura: infuraRpcUrls.rinkeby,
    public: publicRpcUrls.rinkeby
  },
  blockExplorers: {
    etherscan: etherscanBlockExplorers.rinkeby,
    default: etherscanBlockExplorers.rinkeby
  },
  ens: {
    address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 10299530
  },
  testnet: true
};
var goerli = {
  id: chainId.goerli,
  name: "Goerli",
  network: "goerli",
  nativeCurrency: {
    name: "Goerli Ether",
    symbol: "GOR",
    decimals: 18
  },
  rpcUrls: {
    alchemy: alchemyRpcUrls.goerli,
    default: publicRpcUrls.goerli,
    infura: infuraRpcUrls.goerli,
    public: publicRpcUrls.goerli
  },
  blockExplorers: {
    etherscan: etherscanBlockExplorers.goerli,
    default: etherscanBlockExplorers.goerli
  },
  ens: {
    address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 6507670
  },
  testnet: true
};
var kovan = {
  id: chainId.kovan,
  name: "Kovan",
  network: "kovan",
  nativeCurrency: {
    name: "Kovan Ether",
    symbol: "KOV",
    decimals: 18
  },
  rpcUrls: {
    alchemy: alchemyRpcUrls.kovan,
    default: publicRpcUrls.kovan,
    infura: infuraRpcUrls.kovan,
    public: publicRpcUrls.kovan
  },
  blockExplorers: {
    etherscan: etherscanBlockExplorers.kovan,
    default: etherscanBlockExplorers.kovan
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 30285908
  },
  testnet: true
};
var optimism = {
  id: chainId.optimism,
  name: "Optimism",
  network: "optimism",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    alchemy: alchemyRpcUrls.optimism,
    default: publicRpcUrls.optimism,
    infura: infuraRpcUrls.optimism,
    public: publicRpcUrls.optimism
  },
  blockExplorers: {
    etherscan: etherscanBlockExplorers.optimism,
    default: etherscanBlockExplorers.optimism
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 4286263
  }
};
var optimismKovan = {
  id: chainId.optimismKovan,
  name: "Optimism Kovan",
  network: "optimism-kovan",
  nativeCurrency: {
    name: "Kovan Ether",
    symbol: "KOR",
    decimals: 18
  },
  rpcUrls: {
    alchemy: alchemyRpcUrls.optimismKovan,
    default: publicRpcUrls.optimismKovan,
    infura: infuraRpcUrls.optimismKovan,
    public: publicRpcUrls.optimismKovan
  },
  blockExplorers: {
    etherscan: etherscanBlockExplorers.optimismKovan,
    default: etherscanBlockExplorers.optimismKovan
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 1418387
  },
  testnet: true
};
var polygon = {
  id: chainId.polygon,
  name: "Polygon",
  network: "matic",
  nativeCurrency: {
    name: "MATIC",
    symbol: "MATIC",
    decimals: 18
  },
  rpcUrls: {
    alchemy: alchemyRpcUrls.polygon,
    default: publicRpcUrls.polygon,
    infura: infuraRpcUrls.polygon,
    public: publicRpcUrls.polygon
  },
  blockExplorers: {
    etherscan: etherscanBlockExplorers.polygon,
    default: etherscanBlockExplorers.polygon
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 25770160
  }
};
var polygonMumbai = {
  id: chainId.polygonMumbai,
  name: "Polygon Mumbai",
  network: "maticmum",
  nativeCurrency: {
    name: "MATIC",
    symbol: "MATIC",
    decimals: 18
  },
  rpcUrls: {
    alchemy: alchemyRpcUrls.polygonMumbai,
    default: publicRpcUrls.polygonMumbai,
    infura: infuraRpcUrls.polygonMumbai,
    public: publicRpcUrls.polygonMumbai
  },
  blockExplorers: {
    etherscan: etherscanBlockExplorers.polygonMumbai,
    default: etherscanBlockExplorers.polygonMumbai
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 25444704
  },
  testnet: true
};
var arbitrum = {
  id: chainId.arbitrum,
  name: "Arbitrum One",
  network: "arbitrum",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    alchemy: alchemyRpcUrls.arbitrum,
    default: publicRpcUrls.arbitrum,
    infura: infuraRpcUrls.arbitrum,
    public: publicRpcUrls.arbitrum
  },
  blockExplorers: {
    arbitrum: {
      name: "Arbitrum Explorer",
      url: "https://explorer.arbitrum.io"
    },
    etherscan: etherscanBlockExplorers.arbitrum,
    default: etherscanBlockExplorers.arbitrum
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 7654707
  }
};
var arbitrumRinkeby = {
  id: chainId.arbitrumRinkeby,
  name: "Arbitrum Rinkeby",
  network: "arbitrum-rinkeby",
  nativeCurrency: {
    name: "Arbitrum Rinkeby Ether",
    symbol: "ARETH",
    decimals: 18
  },
  rpcUrls: {
    alchemy: alchemyRpcUrls.arbitrumRinkeby,
    default: publicRpcUrls.arbitrumRinkeby,
    infura: infuraRpcUrls.arbitrumRinkeby,
    public: publicRpcUrls.arbitrumRinkeby
  },
  blockExplorers: {
    arbitrum: {
      name: "Arbitrum Explorer",
      url: "https://rinkeby-explorer.arbitrum.io"
    },
    etherscan: etherscanBlockExplorers.arbitrumRinkeby,
    default: etherscanBlockExplorers.arbitrumRinkeby
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 10228837
  },
  testnet: true
};
var localhost = {
  id: chainId.localhost,
  name: "Localhost",
  network: "localhost",
  rpcUrls: {
    default: "http://127.0.0.1:8545"
  }
};
var hardhat = {
  id: chainId.hardhat,
  name: "Hardhat",
  network: "hardhat",
  rpcUrls: {
    default: "http://127.0.0.1:8545"
  }
};
var foundry = {
  id: chainId.foundry,
  name: "Foundry",
  network: "foundry",
  rpcUrls: {
    default: "http://127.0.0.1:8545"
  }
};
var chain = {
  mainnet,
  ropsten,
  rinkeby,
  goerli,
  kovan,
  optimism,
  optimismKovan,
  polygon,
  polygonMumbai,
  arbitrum,
  arbitrumRinkeby,
  localhost,
  hardhat,
  foundry
};
var allChains = Object.values(chain);
var defaultChains = [chain.mainnet, chain.ropsten, chain.rinkeby, chain.goerli, chain.kovan];
var defaultL2Chains = [chain.arbitrum, chain.arbitrumRinkeby, chain.optimism, chain.optimismKovan];

// node_modules/@wagmi/core/dist/base-b565d5d4.esm.js
var import_eventemitter3 = __toESM(require_eventemitter3());
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateMethodInitSpec(obj, privateSet) {
  _checkPrivateRedeclaration(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateMethodGet(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}
function normalizeChainId(chainId2) {
  if (typeof chainId2 === "string")
    return Number.parseInt(chainId2, chainId2.trim().substring(0, 2) === "0x" ? 16 : 10);
  if (typeof chainId2 === "bigint")
    return Number(chainId2);
  return chainId2;
}
var RpcError = class extends Error {
  constructor(code, message, internal, data) {
    if (!Number.isInteger(code))
      throw new Error('"code" must be an integer.');
    if (!message || typeof message !== "string")
      throw new Error('"message" must be a nonempty string.');
    super(message);
    _defineProperty(this, "code", void 0);
    _defineProperty(this, "data", void 0);
    _defineProperty(this, "internal", void 0);
    this.code = code;
    this.data = data;
    this.internal = internal;
  }
};
var ProviderRpcError = class extends RpcError {
  constructor(code, message, internal, data) {
    if (!(Number.isInteger(code) && code >= 1e3 && code <= 4999))
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(code, message, internal, data);
  }
};
var AddChainError = class extends Error {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", "AddChainError");
    _defineProperty(this, "message", "Error adding chain");
  }
};
var ChainDoesNotSupportMulticallError = class extends Error {
  constructor(_ref) {
    let {
      blockNumber,
      chain: chain2
    } = _ref;
    super('Chain "'.concat(chain2.name, '" does not support multicall').concat(blockNumber ? " on block ".concat(blockNumber) : "", "."));
    _defineProperty(this, "name", "ChainDoesNotSupportMulticall");
  }
};
var ChainMismatchError = class extends Error {
  constructor(_ref2) {
    let {
      activeChain,
      targetChain
    } = _ref2;
    super('Chain mismatch: Expected "'.concat(targetChain, '", received "').concat(activeChain, "."));
    _defineProperty(this, "name", "ChainMismatchError");
  }
};
var ChainNotConfiguredError = class extends Error {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", "ChainNotConfigured");
    _defineProperty(this, "message", "Chain not configured");
  }
};
var ConnectorAlreadyConnectedError = class extends Error {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", "ConnectorAlreadyConnectedError");
    _defineProperty(this, "message", "Connector already connected");
  }
};
var ConnectorNotFoundError = class extends Error {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", "ConnectorNotFoundError");
    _defineProperty(this, "message", "Connector not found");
  }
};
var ContractMethodNoResultError = class extends Error {
  constructor(_ref3) {
    let {
      addressOrName,
      blockExplorer,
      functionName
    } = _ref3;
    super(['Function "'.concat(functionName, '" on contract "').concat(addressOrName, '" returned an empty response.'), "", 'Are you sure the function "'.concat(functionName, '" exists on this contract?'), ...blockExplorer ? ["", "".concat(blockExplorer === null || blockExplorer === void 0 ? void 0 : blockExplorer.name, ": ").concat(blockExplorer === null || blockExplorer === void 0 ? void 0 : blockExplorer.url, "/address/").concat(addressOrName, "#readContract")] : []].join("\n"));
    _defineProperty(this, "name", "ContractMethodNoResultError");
  }
};
var ProviderChainsNotFound = class extends Error {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", "ProviderChainsNotFound");
    _defineProperty(this, "message", ["No chains were found on the wagmi provider. Some functions that require a chain may not work.", "", "It is recommended to add a list of chains to the provider in `createClient`.", "", "Example:", "", "```", "import { getDefaultProvider } from 'ethers'", "import { chain, createClient } from 'wagmi'", "", "createClient({", "  provider: Object.assign(getDefaultProvider(), { chains: [chain.mainnet] })", "})", "```"].join("\n"));
  }
};
var ResourceUnavailableError = class extends RpcError {
  constructor(error) {
    super(-32002, "Resource unavailable", error);
    _defineProperty(this, "name", "ResourceUnavailable");
  }
};
var SwitchChainError = class extends ProviderRpcError {
  constructor(error) {
    super(4902, "Error switching chain", error);
    _defineProperty(this, "name", "SwitchChainError");
  }
};
var SwitchChainNotSupportedError = class extends Error {
  constructor(_ref4) {
    let {
      connector
    } = _ref4;
    super('"'.concat(connector.name, '" does not support programmatic chain switching.'));
    _defineProperty(this, "name", "SwitchChainNotSupportedError");
  }
};
var UserRejectedRequestError = class extends ProviderRpcError {
  constructor(error) {
    super(4001, "User rejected request", error);
    _defineProperty(this, "name", "UserRejectedRequestError");
  }
};
var Connector = class extends import_eventemitter3.default {
  constructor(_ref) {
    let {
      chains = defaultChains,
      options
    } = _ref;
    super();
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "chains", void 0);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "ready", void 0);
    this.chains = chains;
    this.options = options;
  }
  getBlockExplorerUrls(chain2) {
    var _chain$blockExplorers;
    const {
      default: blockExplorer,
      ...blockExplorers
    } = (_chain$blockExplorers = chain2.blockExplorers) !== null && _chain$blockExplorers !== void 0 ? _chain$blockExplorers : {};
    if (blockExplorer)
      return [blockExplorer.url, ...Object.values(blockExplorers).map((x) => x.url)];
    return [];
  }
  isChainUnsupported(chainId2) {
    return !this.chains.some((x) => x.id === chainId2);
  }
};

// node_modules/zustand/esm/vanilla.js
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (nextState !== state) {
      const previousState = state;
      state = replace ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => listeners.clear();
  const api = { setState, getState, subscribe, destroy };
  state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// node_modules/zustand/esm/middleware.js
var subscribeWithSelectorImpl = (fn) => (set, get, api) => {
  const origSubscribe = api.subscribe;
  api.subscribe = (selector, optListener, options) => {
    let listener = selector;
    if (optListener) {
      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
      let currentSlice = selector(api.getState());
      listener = (state) => {
        const nextSlice = selector(state);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      };
      if (options == null ? void 0 : options.fireImmediately) {
        optListener(currentSlice, currentSlice);
      }
    }
    return origSubscribe(listener);
  };
  const initialState = fn(set, get, api);
  return initialState;
};
var subscribeWithSelector = subscribeWithSelectorImpl;
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var toThenable = (fn) => (input) => {
  try {
    const result = fn(input);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e);
      }
    };
  }
};
var persistImpl = (config, baseOptions) => (set, get, api) => {
  let options = __spreadValues({
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => __spreadValues(__spreadValues({}, currentState), persistedState)
  }, baseOptions);
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage;
  try {
    storage = options.getStorage();
  } catch (e) {
  }
  if (!storage) {
    return config((...args) => {
      console.warn(`[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`);
      set(...args);
    }, get, api);
  }
  const thenableSerialize = toThenable(options.serialize);
  const setItem = () => {
    const state = options.partialize(__spreadValues({}, get()));
    let errorInSync;
    const thenable = thenableSerialize({ state, version: options.version }).then((serializedValue) => storage.setItem(options.name, serializedValue)).catch((e) => {
      errorInSync = e;
    });
    if (errorInSync) {
      throw errorInSync;
    }
    return thenable;
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config((...args) => {
    set(...args);
    void setItem();
  }, get, api);
  let stateFromStorage;
  const hydrate2 = () => {
    var _a;
    if (!storage)
      return;
    hasHydrated = false;
    hydrationListeners.forEach((cb) => cb(get()));
    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
      if (storageValue) {
        return options.deserialize(storageValue);
      }
    }).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return options.migrate(deserializedStorageValue.state, deserializedStorageValue.version);
          }
          console.error(`State loaded from storage couldn't be migrated since no migrate function was provided`);
        } else {
          return deserializedStorageValue.state;
        }
      }
    }).then((migratedState) => {
      var _a2;
      stateFromStorage = options.merge(migratedState, (_a2 = get()) != null ? _a2 : configResult);
      set(stateFromStorage, true);
      return setItem();
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      hasHydrated = true;
      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
    }).catch((e) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = __spreadValues(__spreadValues({}, options), newOptions);
      if (newOptions.getStorage) {
        storage = newOptions.getStorage();
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    rehydrate: () => hydrate2(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb) => {
      hydrationListeners.add(cb);
      return () => {
        hydrationListeners.delete(cb);
      };
    },
    onFinishHydration: (cb) => {
      finishHydrationListeners.add(cb);
      return () => {
        finishHydrationListeners.delete(cb);
      };
    }
  };
  hydrate2();
  return stateFromStorage || configResult;
};
var persist = persistImpl;

// node_modules/@wagmi/core/dist/client-a05fd511.esm.js
var import_utils = __toESM(require_utils());
function getInjectedName(ethereum) {
  var _ethereum$providers, _getName;
  if (!ethereum)
    return "Injected";
  const getName = (provider) => {
    if (provider.isBraveWallet)
      return "Brave Wallet";
    if (provider.isCoinbaseWallet)
      return "Coinbase Wallet";
    if (provider.isExodus)
      return "Exodus";
    if (provider.isFrame)
      return "Frame";
    if (provider.isOpera)
      return "Opera";
    if (provider.isTally)
      return "Tally";
    if (provider.isTokenPocket)
      return "TokenPocket";
    if (provider.isTokenary)
      return "Tokenary";
    if (provider.isTrust)
      return "Trust Wallet";
    if (provider.isMetaMask)
      return "MetaMask";
  };
  if ((_ethereum$providers = ethereum.providers) !== null && _ethereum$providers !== void 0 && _ethereum$providers.length) {
    var _names$;
    const nameSet = /* @__PURE__ */ new Set();
    let unknownCount = 1;
    for (const provider of ethereum.providers) {
      let name = getName(provider);
      if (!name) {
        name = "Unknown Wallet #".concat(unknownCount);
        unknownCount += 1;
      }
      nameSet.add(name);
    }
    const names = [...nameSet];
    if (names.length)
      return names;
    return (_names$ = names[0]) !== null && _names$ !== void 0 ? _names$ : "Injected";
  }
  return (_getName = getName(ethereum)) !== null && _getName !== void 0 ? _getName : "Injected";
}
var shimDisconnectKey = "injected.shimDisconnect";
var _provider = /* @__PURE__ */ new WeakMap();
var _switchingChains = /* @__PURE__ */ new WeakMap();
var InjectedConnector = class extends Connector {
  constructor() {
    let {
      chains,
      options = {
        shimDisconnect: true
      }
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super({
      chains,
      options
    });
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "ready", typeof window != "undefined" && !!window.ethereum);
    _classPrivateFieldInitSpec(this, _provider, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _switchingChains, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "onAccountsChanged", (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", {
          account: (0, import_utils.getAddress)(accounts[0])
        });
    });
    _defineProperty(this, "onChainChanged", (chainId2) => {
      const id = normalizeChainId(chainId2);
      const unsupported = this.isChainUnsupported(id);
      this.emit("change", {
        chain: {
          id,
          unsupported
        }
      });
    });
    _defineProperty(this, "onDisconnect", () => {
      var _this$options, _this$options2, _getClient$storage;
      if ((_this$options = this.options) !== null && _this$options !== void 0 && _this$options.shimChainChangedDisconnect && _classPrivateFieldGet(this, _switchingChains)) {
        _classPrivateFieldSet(this, _switchingChains, false);
        return;
      }
      this.emit("disconnect");
      if ((_this$options2 = this.options) !== null && _this$options2 !== void 0 && _this$options2.shimDisconnect)
        (_getClient$storage = getClient().storage) === null || _getClient$storage === void 0 ? void 0 : _getClient$storage.removeItem(shimDisconnectKey);
    });
    let name = "Injected";
    if (typeof window !== "undefined") {
      const overrideName = options.name;
      const detectedName = getInjectedName(window.ethereum);
      if (overrideName)
        name = typeof overrideName === "function" ? overrideName(detectedName) : overrideName;
      else
        name = typeof detectedName === "string" ? detectedName : detectedName[0];
    }
    this.id = "injected";
    this.name = name;
  }
  async connect() {
    let {
      chainId: chainId2
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    try {
      var _this$options3, _getClient$storage2;
      const provider = await this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      if (provider.on) {
        provider.on("accountsChanged", this.onAccountsChanged);
        provider.on("chainChanged", this.onChainChanged);
        provider.on("disconnect", this.onDisconnect);
      }
      this.emit("message", {
        type: "connecting"
      });
      const account = await this.getAccount();
      let id = await this.getChainId();
      let unsupported = this.isChainUnsupported(id);
      if (chainId2 && id !== chainId2) {
        const chain2 = await this.switchChain(chainId2);
        id = chain2.id;
        unsupported = this.isChainUnsupported(id);
      }
      if ((_this$options3 = this.options) !== null && _this$options3 !== void 0 && _this$options3.shimDisconnect)
        (_getClient$storage2 = getClient().storage) === null || _getClient$storage2 === void 0 ? void 0 : _getClient$storage2.setItem(shimDisconnectKey, true);
      return {
        account,
        chain: {
          id,
          unsupported
        },
        provider
      };
    } catch (error) {
      if (this.isUserRejectedRequestError(error))
        throw new UserRejectedRequestError(error);
      if (error.code === -32002)
        throw new ResourceUnavailableError(error);
      throw error;
    }
  }
  async disconnect() {
    var _this$options4, _getClient$storage3;
    const provider = await this.getProvider();
    if (!(provider !== null && provider !== void 0 && provider.removeListener))
      return;
    provider.removeListener("accountsChanged", this.onAccountsChanged);
    provider.removeListener("chainChanged", this.onChainChanged);
    provider.removeListener("disconnect", this.onDisconnect);
    if ((_this$options4 = this.options) !== null && _this$options4 !== void 0 && _this$options4.shimDisconnect)
      (_getClient$storage3 = getClient().storage) === null || _getClient$storage3 === void 0 ? void 0 : _getClient$storage3.removeItem(shimDisconnectKey);
  }
  async getAccount() {
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    const accounts = await provider.request({
      method: "eth_requestAccounts"
    });
    return (0, import_utils.getAddress)(accounts[0]);
  }
  async getChainId() {
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    return await provider.request({
      method: "eth_chainId"
    }).then(normalizeChainId);
  }
  async getProvider() {
    if (typeof window !== "undefined" && !!window.ethereum)
      _classPrivateFieldSet(this, _provider, window.ethereum);
    return _classPrivateFieldGet(this, _provider);
  }
  async getSigner() {
    const [provider, account] = await Promise.all([this.getProvider(), this.getAccount()]);
    return new lib_exports25.Web3Provider(provider).getSigner(account);
  }
  async isAuthorized() {
    try {
      var _this$options5, _getClient$storage4;
      if ((_this$options5 = this.options) !== null && _this$options5 !== void 0 && _this$options5.shimDisconnect && !((_getClient$storage4 = getClient().storage) !== null && _getClient$storage4 !== void 0 && _getClient$storage4.getItem(shimDisconnectKey)))
        return false;
      const provider = await this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      const accounts = await provider.request({
        method: "eth_accounts"
      });
      const account = accounts[0];
      return !!account;
    } catch {
      return false;
    }
  }
  async switchChain(chainId2) {
    var _this$options6;
    if ((_this$options6 = this.options) !== null && _this$options6 !== void 0 && _this$options6.shimChainChangedDisconnect)
      _classPrivateFieldSet(this, _switchingChains, true);
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    const id = (0, import_utils.hexValue)(chainId2);
    try {
      var _this$chains$find;
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{
          chainId: id
        }]
      });
      return (_this$chains$find = this.chains.find((x) => x.id === chainId2)) !== null && _this$chains$find !== void 0 ? _this$chains$find : {
        id: chainId2,
        name: "Chain ".concat(id),
        network: "".concat(id),
        rpcUrls: {
          default: ""
        }
      };
    } catch (error) {
      var _data, _data$originalError;
      const chain2 = this.chains.find((x) => x.id === chainId2);
      if (!chain2)
        throw new ChainNotConfiguredError();
      if (error.code === 4902 || (error === null || error === void 0 ? void 0 : (_data = error.data) === null || _data === void 0 ? void 0 : (_data$originalError = _data.originalError) === null || _data$originalError === void 0 ? void 0 : _data$originalError.code) === 4902) {
        try {
          var _chain$rpcUrls$public;
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: id,
              chainName: chain2.name,
              nativeCurrency: chain2.nativeCurrency,
              rpcUrls: [(_chain$rpcUrls$public = chain2.rpcUrls.public) !== null && _chain$rpcUrls$public !== void 0 ? _chain$rpcUrls$public : chain2.rpcUrls.default],
              blockExplorerUrls: this.getBlockExplorerUrls(chain2)
            }]
          });
          return chain2;
        } catch (addError) {
          if (this.isUserRejectedRequestError(addError))
            throw new UserRejectedRequestError(error);
          throw new AddChainError();
        }
      }
      if (this.isUserRejectedRequestError(error))
        throw new UserRejectedRequestError(error);
      throw new SwitchChainError(error);
    }
  }
  async watchAsset(_ref) {
    let {
      address,
      decimals = 18,
      image,
      symbol
    } = _ref;
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    return await provider.request({
      method: "wallet_watchAsset",
      params: {
        type: "ERC20",
        options: {
          address,
          decimals,
          image,
          symbol
        }
      }
    });
  }
  isUserRejectedRequestError(error) {
    return error.code === 4001;
  }
};
var noopStorage = {
  getItem: (_key) => "",
  setItem: (_key, _value) => null,
  removeItem: (_key) => null
};
function createStorage(_ref) {
  let {
    storage,
    key: prefix = "wagmi"
  } = _ref;
  return {
    ...storage,
    getItem: function(key) {
      let defaultState = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      const value = storage.getItem("".concat(prefix, ".").concat(key));
      try {
        return value ? JSON.parse(value) : defaultState;
      } catch (error) {
        console.warn(error);
        return defaultState;
      }
    },
    setItem: (key, value) => {
      if (value === null) {
        storage.removeItem("".concat(prefix, ".").concat(key));
      } else {
        try {
          storage.setItem("".concat(prefix, ".").concat(key), JSON.stringify(value));
        } catch (err) {
          console.error(err);
        }
      }
    },
    removeItem: (key) => storage.removeItem("".concat(prefix, ".").concat(key))
  };
}
var storeKey = "store";
var _isAutoConnecting = /* @__PURE__ */ new WeakMap();
var _lastUsedConnector = /* @__PURE__ */ new WeakMap();
var _addEffects = /* @__PURE__ */ new WeakSet();
var Client = class {
  constructor(_ref) {
    let {
      autoConnect = false,
      connectors = [new InjectedConnector()],
      provider: _provider2,
      storage = createStorage({
        storage: typeof window !== "undefined" ? window.localStorage : noopStorage
      }),
      webSocketProvider: _webSocketProvider
    } = _ref;
    _classPrivateMethodInitSpec(this, _addEffects);
    _defineProperty(this, "config", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "store", void 0);
    _classPrivateFieldInitSpec(this, _isAutoConnecting, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _lastUsedConnector, {
      writable: true,
      value: void 0
    });
    let status = "disconnected";
    let _chainId;
    if (autoConnect) {
      try {
        var _JSON$parse, _JSON$parse$state, _data$chain;
        const rawState = storage.getItem(storeKey, "");
        const data = (_JSON$parse = JSON.parse(rawState || "{}")) === null || _JSON$parse === void 0 ? void 0 : (_JSON$parse$state = _JSON$parse.state) === null || _JSON$parse$state === void 0 ? void 0 : _JSON$parse$state.data;
        status = data !== null && data !== void 0 && data.account ? "reconnecting" : "connecting";
        _chainId = data === null || data === void 0 ? void 0 : (_data$chain = data.chain) === null || _data$chain === void 0 ? void 0 : _data$chain.id;
      } catch (_error) {
      }
    }
    this.store = createStore(subscribeWithSelector(persist(() => ({
      connectors: typeof connectors === "function" ? connectors() : connectors,
      provider: typeof _provider2 === "function" ? _provider2({
        chainId: _chainId
      }) : _provider2,
      status,
      webSocketProvider: typeof _webSocketProvider === "function" ? _webSocketProvider({
        chainId: _chainId
      }) : _webSocketProvider
    }), {
      name: storeKey,
      getStorage: () => storage,
      partialize: (state) => {
        var _state$data, _state$data2;
        return {
          ...autoConnect && {
            data: {
              account: state === null || state === void 0 ? void 0 : (_state$data = state.data) === null || _state$data === void 0 ? void 0 : _state$data.account,
              chain: state === null || state === void 0 ? void 0 : (_state$data2 = state.data) === null || _state$data2 === void 0 ? void 0 : _state$data2.chain
            }
          },
          chains: state === null || state === void 0 ? void 0 : state.chains
        };
      },
      version: 1
    })));
    this.config = {
      autoConnect,
      connectors,
      provider: _provider2,
      storage,
      webSocketProvider: _webSocketProvider
    };
    this.storage = storage;
    _classPrivateFieldSet(this, _lastUsedConnector, storage === null || storage === void 0 ? void 0 : storage.getItem("wallet"));
    _classPrivateMethodGet(this, _addEffects, _addEffects2).call(this);
  }
  get chains() {
    return this.store.getState().chains;
  }
  get connectors() {
    return this.store.getState().connectors;
  }
  get connector() {
    return this.store.getState().connector;
  }
  get data() {
    return this.store.getState().data;
  }
  get error() {
    return this.store.getState().error;
  }
  get lastUsedChainId() {
    var _this$data, _this$data$chain;
    return (_this$data = this.data) === null || _this$data === void 0 ? void 0 : (_this$data$chain = _this$data.chain) === null || _this$data$chain === void 0 ? void 0 : _this$data$chain.id;
  }
  get provider() {
    return this.store.getState().provider;
  }
  get status() {
    return this.store.getState().status;
  }
  get subscribe() {
    return this.store.subscribe;
  }
  get webSocketProvider() {
    return this.store.getState().webSocketProvider;
  }
  setState(updater) {
    const newState = typeof updater === "function" ? updater(this.store.getState()) : updater;
    this.store.setState(newState, true);
  }
  clearState() {
    this.setState((x) => ({
      ...x,
      connector: void 0,
      data: void 0,
      error: void 0,
      status: "disconnected"
    }));
  }
  async destroy() {
    var _this$connector$disco, _this$connector;
    if (this.connector)
      await ((_this$connector$disco = (_this$connector = this.connector).disconnect) === null || _this$connector$disco === void 0 ? void 0 : _this$connector$disco.call(_this$connector));
    _classPrivateFieldSet(this, _isAutoConnecting, false);
    this.clearState();
    this.store.destroy();
  }
  async autoConnect() {
    if (_classPrivateFieldGet(this, _isAutoConnecting))
      return;
    _classPrivateFieldSet(this, _isAutoConnecting, true);
    if (!this.connectors.length)
      return;
    const sorted = _classPrivateFieldGet(this, _lastUsedConnector) ? [...this.connectors].sort((x) => x.id === _classPrivateFieldGet(this, _lastUsedConnector) ? -1 : 1) : this.connectors;
    let connected = false;
    for (const connector of sorted) {
      if (!connector.ready || !connector.isAuthorized)
        continue;
      const isAuthorized = await connector.isAuthorized();
      if (!isAuthorized)
        continue;
      const data = await connector.connect();
      this.setState((x) => ({
        ...x,
        connector,
        chains: connector === null || connector === void 0 ? void 0 : connector.chains,
        data,
        status: "connected"
      }));
      connected = true;
      break;
    }
    if (!connected)
      this.setState((x) => ({
        ...x,
        data: void 0,
        status: "disconnected"
      }));
    _classPrivateFieldSet(this, _isAutoConnecting, false);
    return this.data;
  }
  setLastUsedConnector() {
    var _this$storage;
    let lastUsedConnector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    (_this$storage = this.storage) === null || _this$storage === void 0 ? void 0 : _this$storage.setItem("wallet", lastUsedConnector);
  }
};
function _addEffects2() {
  const onChange = (data) => {
    this.setState((x) => ({
      ...x,
      data: {
        ...x.data,
        ...data
      }
    }));
  };
  const onDisconnect = () => {
    this.clearState();
  };
  const onError = (error) => {
    this.setState((x) => ({
      ...x,
      error
    }));
  };
  this.store.subscribe((_ref2) => {
    let {
      connector
    } = _ref2;
    return connector;
  }, (connector, prevConnector) => {
    var _prevConnector$off, _prevConnector$off2, _prevConnector$off3, _connector$on, _connector$on2, _connector$on3;
    prevConnector === null || prevConnector === void 0 ? void 0 : (_prevConnector$off = prevConnector.off) === null || _prevConnector$off === void 0 ? void 0 : _prevConnector$off.call(prevConnector, "change", onChange);
    prevConnector === null || prevConnector === void 0 ? void 0 : (_prevConnector$off2 = prevConnector.off) === null || _prevConnector$off2 === void 0 ? void 0 : _prevConnector$off2.call(prevConnector, "disconnect", onDisconnect);
    prevConnector === null || prevConnector === void 0 ? void 0 : (_prevConnector$off3 = prevConnector.off) === null || _prevConnector$off3 === void 0 ? void 0 : _prevConnector$off3.call(prevConnector, "error", onError);
    if (!connector)
      return;
    (_connector$on = connector.on) === null || _connector$on === void 0 ? void 0 : _connector$on.call(connector, "change", onChange);
    (_connector$on2 = connector.on) === null || _connector$on2 === void 0 ? void 0 : _connector$on2.call(connector, "disconnect", onDisconnect);
    (_connector$on3 = connector.on) === null || _connector$on3 === void 0 ? void 0 : _connector$on3.call(connector, "error", onError);
  });
  const {
    provider,
    webSocketProvider
  } = this.config;
  const subscribeProvider = typeof provider === "function";
  const subscribeWebSocketProvider = typeof webSocketProvider === "function";
  if (subscribeProvider || subscribeWebSocketProvider)
    this.store.subscribe((_ref3) => {
      var _data$chain2;
      let {
        data
      } = _ref3;
      return data === null || data === void 0 ? void 0 : (_data$chain2 = data.chain) === null || _data$chain2 === void 0 ? void 0 : _data$chain2.id;
    }, (chainId2) => {
      this.setState((x) => ({
        ...x,
        provider: subscribeProvider ? provider({
          chainId: chainId2
        }) : x.provider,
        webSocketProvider: subscribeWebSocketProvider ? webSocketProvider({
          chainId: chainId2
        }) : x.webSocketProvider
      }));
    });
}
var client;
function createClient(config) {
  const client_ = new Client(config);
  client = client_;
  return client_;
}
function getClient() {
  if (!client) {
    throw new Error("No wagmi client found. Ensure you have set up a client: https://wagmi.sh/docs/client");
  }
  return client;
}

// node_modules/@wagmi/core/dist/wagmi-core.esm.js
var import_ethers2 = __toESM(require_ethers());
var import_utils2 = __toESM(require_utils());

// node_modules/zustand/esm/shallow.js
function shallow(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}

// node_modules/@wagmi/core/dist/wagmi-core.esm.js
var import_eventemitter32 = __toESM(require_eventemitter3());
function configureChains(defaultChains2, providers) {
  let {
    minQuorum = 1,
    targetQuorum = 1,
    stallTimeout
  } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!defaultChains2.length)
    throw new Error("must have at least one chain");
  if (targetQuorum < minQuorum)
    throw new Error("quorum cannot be lower than minQuorum");
  let chains = [];
  const providers_ = {};
  const webSocketProviders_ = {};
  for (const chain2 of defaultChains2) {
    let configExists = false;
    for (const provider of providers) {
      const apiConfig = provider(chain2);
      if (!apiConfig)
        continue;
      configExists = true;
      if (!chains.some((_ref) => {
        let {
          id
        } = _ref;
        return id === chain2.id;
      })) {
        chains = [...chains, apiConfig.chain];
      }
      providers_[chain2.id] = [...providers_[chain2.id] || [], apiConfig.provider];
      if (apiConfig.webSocketProvider) {
        webSocketProviders_[chain2.id] = [...webSocketProviders_[chain2.id] || [], apiConfig.webSocketProvider];
      }
    }
    if (!configExists) {
      throw new Error(['Could not find valid provider configuration for chain "'.concat(chain2.name, '".\n'), "You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.", "Read more: https://wagmi.sh/docs/providers/jsonRpc"].join("\n"));
    }
  }
  return {
    chains,
    provider: (_ref2) => {
      var _defaultChains$, _chainProviders$;
      let {
        chainId: chainId2
      } = _ref2;
      const activeChainId = chainId2 && chains.some((x) => x.id === chainId2) ? chainId2 : (_defaultChains$ = defaultChains2[0]) === null || _defaultChains$ === void 0 ? void 0 : _defaultChains$.id;
      const chainProviders = providers_[activeChainId];
      if (!chainProviders)
        throw new Error('No providers configured for chain "'.concat(activeChainId, '"'));
      if (chainProviders.length === 1)
        return Object.assign(((_chainProviders$ = chainProviders[0]) === null || _chainProviders$ === void 0 ? void 0 : _chainProviders$.call(chainProviders)) || {}, {
          chains
        });
      return Object.assign(fallbackProvider(targetQuorum, minQuorum, chainProviders, {
        stallTimeout
      }), {
        chains
      });
    },
    webSocketProvider: (_ref3) => {
      var _defaultChains$2, _chainWebSocketProvid;
      let {
        chainId: chainId2
      } = _ref3;
      const activeChainId = chainId2 && chains.some((x) => x.id === chainId2) ? chainId2 : (_defaultChains$2 = defaultChains2[0]) === null || _defaultChains$2 === void 0 ? void 0 : _defaultChains$2.id;
      const chainWebSocketProviders = webSocketProviders_[activeChainId];
      if (!chainWebSocketProviders)
        return void 0;
      return Object.assign(((_chainWebSocketProvid = chainWebSocketProviders[0]) === null || _chainWebSocketProvid === void 0 ? void 0 : _chainWebSocketProvid.call(chainWebSocketProviders)) || {}, {
        chains
      });
    }
  };
}
function fallbackProvider(targetQuorum, minQuorum, providers_, _ref4) {
  let {
    stallTimeout
  } = _ref4;
  try {
    return new lib_exports25.FallbackProvider(providers_.map((chainProvider, index) => {
      var _provider$priority, _provider$stallTimeou;
      const provider = chainProvider();
      return {
        provider,
        priority: (_provider$priority = provider.priority) !== null && _provider$priority !== void 0 ? _provider$priority : index,
        stallTimeout: (_provider$stallTimeou = provider.stallTimeout) !== null && _provider$stallTimeou !== void 0 ? _provider$stallTimeou : stallTimeout,
        weight: provider.weight
      };
    }), targetQuorum);
  } catch (error) {
    var _error$message;
    if (error !== null && error !== void 0 && (_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes("quorum will always fail; larger than total weight")) {
      if (targetQuorum === minQuorum)
        throw error;
      return fallbackProvider(targetQuorum - 1, minQuorum, providers_, {
        stallTimeout
      });
    }
    throw error;
  }
}
function deepEqual(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a === "object" && typeof b === "object") {
    if (a.constructor !== b.constructor)
      return false;
    let length;
    let i;
    if (Array.isArray(a) && Array.isArray(b)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!deepEqual(a[i], b[i]))
          return false;
      return true;
    }
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    const keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key && !deepEqual(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
}
var erc20ABI = ["event Approval(address indexed _owner, address indexed _spender, uint256 _value)", "event Transfer(address indexed _from, address indexed _to, uint256 _value)", "function allowance(address _owner, address _spender) public view returns (uint256 remaining)", "function approve(address _spender, uint256 _value) public returns (bool success)", "function balanceOf(address _owner) public view returns (uint256 balance)", "function decimals() public view returns (uint8)", "function name() public view returns (string)", "function symbol() public view returns (string)", "function totalSupply() public view returns (uint256)", "function transfer(address _to, uint256 _value) public returns (bool success)", "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)"];
var erc721ABI = ["event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId)", "event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)", "event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)", "function approve(address _approved, uint256 _tokenId) external payable", "function balanceOf(address _owner) external view returns (uint256)", "function getApproved(uint256 _tokenId) external view returns (address)", "function isApprovedForAll(address _owner, address _operator) external view returns (bool)", "function name() view returns (string memory)", "function ownerOf(uint256 _tokenId) external view returns (address)", "function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable", "function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable", "function setApprovalForAll(address _operator, bool _approved) external", "function symbol() view returns (string memory)", "function tokenByIndex(uint256 _index) view returns (uint256)", "function tokenOfOwnerByIndex(address _owner, uint256 _index) view returns (uint256 tokenId)", "function tokenURI(uint256 _tokenId) view returns (string memory)", "function totalSupply() view returns (uint256)", "function transferFrom(address _from, address _to, uint256 _tokenId) external payable"];
var multicallInterface = [{
  inputs: [{
    components: [{
      internalType: "address",
      name: "target",
      type: "address"
    }, {
      internalType: "bool",
      name: "allowFailure",
      type: "bool"
    }, {
      internalType: "bytes",
      name: "callData",
      type: "bytes"
    }],
    internalType: "struct Multicall3.Call3[]",
    name: "calls",
    type: "tuple[]"
  }],
  name: "aggregate3",
  outputs: [{
    components: [{
      internalType: "bool",
      name: "success",
      type: "bool"
    }, {
      internalType: "bytes",
      name: "returnData",
      type: "bytes"
    }],
    internalType: "struct Multicall3.Result[]",
    name: "returnData",
    type: "tuple[]"
  }],
  stateMutability: "view",
  type: "function"
}];
async function connect(_ref) {
  let {
    chainId: chainId2,
    connector
  } = _ref;
  const client2 = getClient();
  const activeConnector = client2.connector;
  if (connector.id === (activeConnector === null || activeConnector === void 0 ? void 0 : activeConnector.id))
    throw new ConnectorAlreadyConnectedError();
  try {
    client2.setState((x) => ({
      ...x,
      status: "connecting"
    }));
    const data = await connector.connect({
      chainId: chainId2
    });
    client2.setLastUsedConnector(connector.id);
    client2.setState((x) => ({
      ...x,
      connector,
      chains: connector === null || connector === void 0 ? void 0 : connector.chains,
      data,
      status: "connected"
    }));
    client2.storage.setItem("connected", true);
    return {
      ...data,
      connector
    };
  } catch (err) {
    client2.setState((x) => ({
      ...x,
      status: "disconnected"
    }));
    throw err;
  }
}
async function disconnect() {
  const client2 = getClient();
  if (client2.connector)
    await client2.connector.disconnect();
  client2.clearState();
  client2.storage.removeItem("connected");
}
function getContract(_ref) {
  let {
    addressOrName,
    contractInterface,
    signerOrProvider
  } = _ref;
  return new Contract(addressOrName, contractInterface, signerOrProvider);
}
function getProvider() {
  let {
    chainId: chainId2
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const client2 = getClient();
  if (chainId2 && typeof client2.config.provider === "function")
    return client2.config.provider({
      chainId: chainId2
    });
  return client2.provider;
}
function getWebSocketProvider() {
  let {
    chainId: chainId2
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const client2 = getClient();
  if (chainId2 && typeof client2.config.webSocketProvider === "function")
    return client2.config.webSocketProvider({
      chainId: chainId2
    });
  return client2.webSocketProvider;
}
function watchProvider(args, callback) {
  const client2 = getClient();
  const handleChange = async () => callback(getProvider(args));
  const unsubscribe = client2.subscribe((_ref) => {
    let {
      provider
    } = _ref;
    return provider;
  }, handleChange);
  return unsubscribe;
}
function watchWebSocketProvider(args, callback) {
  const client2 = getClient();
  const handleChange = async () => callback(getWebSocketProvider(args));
  const unsubscribe = client2.subscribe((_ref) => {
    let {
      webSocketProvider
    } = _ref;
    return webSocketProvider;
  }, handleChange);
  return unsubscribe;
}
async function readContract(_ref) {
  let {
    addressOrName,
    args,
    chainId: chainId2,
    contractInterface,
    functionName,
    overrides
  } = _ref;
  const provider = getProvider({
    chainId: chainId2
  });
  const contract = getContract({
    addressOrName,
    contractInterface,
    signerOrProvider: provider
  });
  const params = [...Array.isArray(args) ? args : args ? [args] : [], ...overrides ? [overrides] : []];
  const contractFunction = contract[functionName];
  if (!contractFunction)
    console.warn('"'.concat(functionName, '" is not in the interface for contract "').concat(addressOrName, '"'));
  const response = await (contractFunction === null || contractFunction === void 0 ? void 0 : contractFunction(...params));
  return response;
}
async function multicall(_ref) {
  let {
    allowFailure = true,
    chainId: chainId2,
    contracts,
    overrides
  } = _ref;
  const provider = getProvider({
    chainId: chainId2
  });
  if (!provider.chains)
    throw new ProviderChainsNotFound();
  const chain2 = provider.chains.find((chain3) => chain3.id === chainId2) || provider.chains[0];
  if (!chain2)
    throw new ProviderChainsNotFound();
  if (!(chain2 !== null && chain2 !== void 0 && chain2.multicall))
    throw new ChainDoesNotSupportMulticallError({
      chain: chain2
    });
  if (typeof (overrides === null || overrides === void 0 ? void 0 : overrides.blockTag) === "number" && (overrides === null || overrides === void 0 ? void 0 : overrides.blockTag) < chain2.multicall.blockCreated)
    throw new ChainDoesNotSupportMulticallError({
      blockNumber: overrides === null || overrides === void 0 ? void 0 : overrides.blockTag,
      chain: chain2
    });
  const multicallContract = getContract({
    addressOrName: chain2.multicall.address,
    contractInterface: multicallInterface,
    signerOrProvider: provider
  });
  const calls = contracts.map((_ref2) => {
    let {
      addressOrName,
      contractInterface,
      functionName,
      ...config
    } = _ref2;
    const {
      args
    } = config || {};
    const contract = getContract({
      addressOrName,
      contractInterface
    });
    const params2 = Array.isArray(args) ? args : args ? [args] : [];
    const callData = contract.interface.encodeFunctionData(functionName, params2);
    if (!contract[functionName])
      console.warn('"'.concat(functionName, '" is not in the interface for contract "').concat(addressOrName, '"'));
    return {
      target: addressOrName,
      allowFailure,
      callData
    };
  });
  const params = [...[calls], ...overrides ? [overrides] : []];
  const results = await multicallContract.aggregate3(...params);
  return results.map((_ref3, i) => {
    let {
      returnData,
      success
    } = _ref3;
    if (!success)
      return null;
    const {
      addressOrName,
      contractInterface,
      functionName
    } = contracts[i];
    if (returnData === "0x") {
      var _chain$blockExplorers;
      const err = new ContractMethodNoResultError({
        addressOrName,
        blockExplorer: (_chain$blockExplorers = chain2.blockExplorers) === null || _chain$blockExplorers === void 0 ? void 0 : _chain$blockExplorers.default,
        functionName
      });
      if (!allowFailure)
        throw err;
      console.warn(err.message);
      return null;
    }
    const contract = getContract({
      addressOrName,
      contractInterface
    });
    try {
      const result = contract.interface.decodeFunctionResult(functionName, returnData);
      return Array.isArray(result) && result.length === 1 ? result[0] : result;
    } catch (err) {
      if (!allowFailure)
        throw err;
      return null;
    }
  });
}
async function readContracts(_ref) {
  let {
    allowFailure = true,
    contracts,
    overrides
  } = _ref;
  try {
    const provider = getProvider();
    const contractsByChainId = contracts.reduce((contracts2, contract) => {
      var _contract$chainId;
      const chainId2 = (_contract$chainId = contract.chainId) !== null && _contract$chainId !== void 0 ? _contract$chainId : provider.network.chainId;
      return {
        ...contracts2,
        [chainId2]: [...contracts2[chainId2] || [], contract]
      };
    }, {});
    const promises = Object.entries(contractsByChainId).map((_ref2) => {
      let [chainId2, contracts2] = _ref2;
      return multicall({
        allowFailure,
        chainId: parseInt(chainId2),
        contracts: contracts2,
        overrides
      });
    });
    if (allowFailure) {
      return (await Promise.allSettled(promises)).map((result) => {
        if (result.status === "fulfilled")
          return result.value;
        if (result.reason instanceof ChainDoesNotSupportMulticallError) {
          console.warn(result.reason.message);
          throw result.reason;
        }
        return null;
      }).flat();
    }
    return (await Promise.all(promises)).flat();
  } catch (err) {
    if (err instanceof ContractMethodNoResultError)
      throw err;
    const promises = contracts.map((contract) => readContract({
      ...contract,
      overrides
    }));
    if (allowFailure) {
      return (await Promise.allSettled(promises)).map((result) => result.status === "fulfilled" ? result.value : null);
    }
    return await Promise.all(promises);
  }
}
async function fetchBlockNumber() {
  let {
    chainId: chainId2
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const provider = getProvider({
    chainId: chainId2
  });
  const blockNumber = await provider.getBlockNumber();
  return blockNumber;
}
async function writeContract(_ref) {
  let {
    addressOrName,
    args,
    chainId: chainId2,
    contractInterface,
    functionName,
    overrides,
    signerOrProvider
  } = _ref;
  const {
    connector
  } = getClient();
  if (!connector)
    throw new ConnectorNotFoundError();
  const params = [...Array.isArray(args) ? args : args ? [args] : [], ...overrides ? [overrides] : []];
  try {
    var _chain;
    let chain2;
    if (chainId2) {
      const activeChainId = await connector.getChainId();
      if (chainId2 !== activeChainId) {
        var _connector$chains$fin, _connector$chains$fin2, _connector$chains$fin3, _connector$chains$fin4;
        if (connector.switchChain)
          chain2 = await connector.switchChain(chainId2);
        else
          throw new ChainMismatchError({
            activeChain: (_connector$chains$fin = (_connector$chains$fin2 = connector.chains.find((x) => x.id === activeChainId)) === null || _connector$chains$fin2 === void 0 ? void 0 : _connector$chains$fin2.name) !== null && _connector$chains$fin !== void 0 ? _connector$chains$fin : "Chain ".concat(activeChainId),
            targetChain: (_connector$chains$fin3 = (_connector$chains$fin4 = connector.chains.find((x) => x.id === chainId2)) === null || _connector$chains$fin4 === void 0 ? void 0 : _connector$chains$fin4.name) !== null && _connector$chains$fin3 !== void 0 ? _connector$chains$fin3 : "Chain ".concat(chainId2)
          });
      }
    }
    const signer = await connector.getSigner({
      chainId: (_chain = chain2) === null || _chain === void 0 ? void 0 : _chain.id
    });
    const contract = getContract({
      addressOrName,
      contractInterface,
      signerOrProvider
    });
    const contractWithSigner = contract.connect(signer);
    const contractFunction = contractWithSigner[functionName];
    if (!contractFunction)
      console.warn('"'.concat(functionName, '" does not exist in interface for contract "').concat(addressOrName, '"'));
    return await contractFunction(...params);
  } catch (error) {
    if (error.code === 4001)
      throw new UserRejectedRequestError(error);
    throw error;
  }
}
async function fetchBalance(_ref) {
  var _client$chains, _chain$nativeCurrency, _chain$nativeCurrency2, _chain$nativeCurrency3, _chain$nativeCurrency4;
  let {
    addressOrName,
    chainId: chainId2,
    formatUnits: unit = "ether",
    token
  } = _ref;
  const client2 = getClient();
  const provider = getProvider({
    chainId: chainId2
  });
  if (token) {
    const erc20Config = {
      addressOrName: token,
      contractInterface: erc20ABI,
      chainId: chainId2
    };
    let resolvedAddress;
    if ((0, import_utils2.isAddress)(addressOrName))
      resolvedAddress = addressOrName;
    else {
      const address = await provider.resolveName(addressOrName);
      if (!address)
        import_ethers2.logger.throwError("ENS name not configured", import_utils2.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "resolveName(".concat(JSON.stringify(addressOrName), ")")
        });
      resolvedAddress = address;
    }
    const [value2, decimals, symbol] = await readContracts({
      allowFailure: false,
      contracts: [{
        ...erc20Config,
        functionName: "balanceOf",
        args: resolvedAddress
      }, {
        ...erc20Config,
        functionName: "decimals"
      }, {
        ...erc20Config,
        functionName: "symbol"
      }]
    });
    return {
      decimals,
      formatted: (0, import_utils2.formatUnits)(value2 !== null && value2 !== void 0 ? value2 : "0", unit),
      symbol,
      unit,
      value: value2
    };
  }
  const chains = [...client2.provider.chains || [], ...(_client$chains = client2.chains) !== null && _client$chains !== void 0 ? _client$chains : []];
  const value = await provider.getBalance(addressOrName);
  const chain2 = chains.find((x) => x.id === provider.network.chainId);
  return {
    decimals: (_chain$nativeCurrency = chain2 === null || chain2 === void 0 ? void 0 : (_chain$nativeCurrency2 = chain2.nativeCurrency) === null || _chain$nativeCurrency2 === void 0 ? void 0 : _chain$nativeCurrency2.decimals) !== null && _chain$nativeCurrency !== void 0 ? _chain$nativeCurrency : 18,
    formatted: (0, import_utils2.formatUnits)(value !== null && value !== void 0 ? value : "0", unit),
    symbol: (_chain$nativeCurrency3 = chain2 === null || chain2 === void 0 ? void 0 : (_chain$nativeCurrency4 = chain2.nativeCurrency) === null || _chain$nativeCurrency4 === void 0 ? void 0 : _chain$nativeCurrency4.symbol) !== null && _chain$nativeCurrency3 !== void 0 ? _chain$nativeCurrency3 : "ETH",
    unit,
    value
  };
}
async function fetchSigner() {
  var _client$connector, _client$connector$get;
  const client2 = getClient();
  const signer = await ((_client$connector = client2.connector) === null || _client$connector === void 0 ? void 0 : (_client$connector$get = _client$connector.getSigner) === null || _client$connector$get === void 0 ? void 0 : _client$connector$get.call(_client$connector)) || null;
  return signer;
}
function getAccount() {
  const {
    data,
    connector,
    status
  } = getClient();
  switch (status) {
    case "connected":
      return {
        address: data === null || data === void 0 ? void 0 : data.account,
        connector,
        isConnected: true,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "reconnecting":
      return {
        address: data === null || data === void 0 ? void 0 : data.account,
        connector,
        isConnected: !!(data !== null && data !== void 0 && data.account),
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: true,
        status
      };
    case "connecting":
      return {
        address: void 0,
        connector: void 0,
        isConnected: false,
        isConnecting: true,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "disconnected":
      return {
        address: void 0,
        connector: void 0,
        isConnected: false,
        isConnecting: false,
        isDisconnected: true,
        isReconnecting: false,
        status
      };
  }
}
function getNetwork() {
  var _client$data, _client$data$chain, _client$chains, _find, _client$data2;
  const client2 = getClient();
  const chainId2 = (_client$data = client2.data) === null || _client$data === void 0 ? void 0 : (_client$data$chain = _client$data.chain) === null || _client$data$chain === void 0 ? void 0 : _client$data$chain.id;
  const activeChains = (_client$chains = client2.chains) !== null && _client$chains !== void 0 ? _client$chains : [];
  const activeChain = (_find = [...client2.provider.chains || [], ...activeChains].find((x) => x.id === chainId2)) !== null && _find !== void 0 ? _find : {
    id: chainId2,
    name: "Chain ".concat(chainId2),
    network: "".concat(chainId2),
    rpcUrls: {
      default: ""
    }
  };
  return {
    chain: chainId2 ? {
      ...activeChain,
      ...(_client$data2 = client2.data) === null || _client$data2 === void 0 ? void 0 : _client$data2.chain,
      id: chainId2
    } : void 0,
    chains: activeChains
  };
}
async function signMessage(args) {
  try {
    const signer = await fetchSigner();
    if (!signer)
      throw new ConnectorNotFoundError();
    return await signer.signMessage(args.message);
  } catch (error) {
    if (error.code === 4001)
      throw new UserRejectedRequestError(error);
    throw error;
  }
}
async function signTypedData(_ref) {
  let {
    domain,
    types,
    value
  } = _ref;
  const {
    connector
  } = getClient();
  if (!connector)
    throw new ConnectorNotFoundError();
  try {
    var _chain;
    const {
      chainId: chainId2
    } = domain;
    let chain2;
    if (chainId2) {
      const chainId_ = normalizeChainId(chainId2);
      const activeChainId = await connector.getChainId();
      if (chainId2 !== activeChainId) {
        var _connector$chains$fin, _connector$chains$fin2, _connector$chains$fin3, _connector$chains$fin4;
        if (connector.switchChain)
          chain2 = await connector.switchChain(chainId_);
        else
          throw new ChainMismatchError({
            activeChain: (_connector$chains$fin = (_connector$chains$fin2 = connector.chains.find((x) => x.id === activeChainId)) === null || _connector$chains$fin2 === void 0 ? void 0 : _connector$chains$fin2.name) !== null && _connector$chains$fin !== void 0 ? _connector$chains$fin : "Chain ".concat(activeChainId),
            targetChain: (_connector$chains$fin3 = (_connector$chains$fin4 = connector.chains.find((x) => x.id === chainId_)) === null || _connector$chains$fin4 === void 0 ? void 0 : _connector$chains$fin4.name) !== null && _connector$chains$fin3 !== void 0 ? _connector$chains$fin3 : "Chain ".concat(chainId_)
          });
      }
    }
    const signer = await connector.getSigner({
      chainId: (_chain = chain2) === null || _chain === void 0 ? void 0 : _chain.id
    });
    return await signer._signTypedData(domain, types, value);
  } catch (error) {
    if (error.code === 4001)
      throw new UserRejectedRequestError(error);
    throw error;
  }
}
async function switchNetwork(_ref) {
  let {
    chainId: chainId2
  } = _ref;
  const {
    connector
  } = getClient();
  if (!connector)
    throw new ConnectorNotFoundError();
  if (!connector.switchChain)
    throw new SwitchChainNotSupportedError({
      connector
    });
  return await connector.switchChain(chainId2);
}
function watchAccount(callback) {
  let {
    selector = (x) => x
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const client2 = getClient();
  const handleChange = () => callback(getAccount());
  const unsubscribe = client2.subscribe((_ref) => {
    let {
      data,
      connector,
      status
    } = _ref;
    return selector({
      address: data === null || data === void 0 ? void 0 : data.account,
      connector,
      status
    });
  }, handleChange, {
    equalityFn: shallow
  });
  return unsubscribe;
}
function watchNetwork(callback) {
  let {
    selector = (x) => x
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const client2 = getClient();
  const handleChange = () => callback(getNetwork());
  const unsubscribe = client2.subscribe((_ref) => {
    var _data$chain;
    let {
      data,
      chains
    } = _ref;
    return selector({
      chainId: data === null || data === void 0 ? void 0 : (_data$chain = data.chain) === null || _data$chain === void 0 ? void 0 : _data$chain.id,
      chains
    });
  }, handleChange, {
    equalityFn: shallow
  });
  return unsubscribe;
}
function watchSigner(callback) {
  const client2 = getClient();
  const handleChange = async () => callback(await fetchSigner());
  const unsubscribe = client2.subscribe((_ref) => {
    var _data$chain;
    let {
      data,
      connector
    } = _ref;
    return {
      account: data === null || data === void 0 ? void 0 : data.account,
      chainId: data === null || data === void 0 ? void 0 : (_data$chain = data.chain) === null || _data$chain === void 0 ? void 0 : _data$chain.id,
      connector
    };
  }, handleChange, {
    equalityFn: shallow
  });
  return unsubscribe;
}
async function fetchEnsAddress(_ref) {
  let {
    chainId: chainId2,
    name
  } = _ref;
  const provider = getProvider({
    chainId: chainId2
  });
  const address = await provider.resolveName(name);
  try {
    return address ? (0, import_utils2.getAddress)(address) : null;
  } catch (_error) {
    return null;
  }
}
async function fetchEnsAvatar(_ref) {
  let {
    addressOrName,
    chainId: chainId2
  } = _ref;
  const provider = getProvider({
    chainId: chainId2
  });
  const avatar = await provider.getAvatar(addressOrName);
  return avatar;
}
async function fetchEnsName(_ref) {
  let {
    address,
    chainId: chainId2
  } = _ref;
  const provider = getProvider({
    chainId: chainId2
  });
  return await provider.lookupAddress(address);
}
async function fetchEnsResolver(_ref) {
  let {
    chainId: chainId2,
    name
  } = _ref;
  const provider = getProvider({
    chainId: chainId2
  });
  const resolver = await provider.getResolver(name);
  return resolver;
}
async function fetchFeeData() {
  let {
    chainId: chainId2,
    formatUnits: units = "wei"
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const provider = getProvider({
    chainId: chainId2
  });
  const feeData = await provider.getFeeData();
  const formatted = {
    gasPrice: feeData.gasPrice ? (0, import_utils2.formatUnits)(feeData.gasPrice, units) : null,
    maxFeePerGas: feeData.maxFeePerGas ? (0, import_utils2.formatUnits)(feeData.maxFeePerGas, units) : null,
    maxPriorityFeePerGas: feeData.maxPriorityFeePerGas ? (0, import_utils2.formatUnits)(feeData.maxPriorityFeePerGas, units) : null
  };
  return {
    ...feeData,
    formatted
  };
}
async function fetchToken(_ref) {
  let {
    address,
    chainId: chainId2,
    formatUnits: units = "ether"
  } = _ref;
  const provider = getProvider({
    chainId: chainId2
  });
  const contract = new import_ethers2.Contract(address, erc20ABI, provider);
  const [symbol, decimals, totalSupply] = await Promise.all([contract.symbol(), contract.decimals(), contract.totalSupply()]);
  const token = {
    address,
    decimals,
    symbol,
    totalSupply: {
      formatted: (0, import_utils2.formatUnits)(totalSupply, units),
      value: totalSupply
    }
  };
  return token;
}
async function sendTransaction(_ref) {
  let {
    chainId: chainId2,
    request
  } = _ref;
  const {
    connector
  } = getClient();
  if (!connector)
    throw new ConnectorNotFoundError();
  try {
    var _chain;
    let chain2;
    if (chainId2) {
      const activeChainId = await connector.getChainId();
      if (chainId2 !== activeChainId) {
        var _connector$chains$fin, _connector$chains$fin2, _connector$chains$fin3, _connector$chains$fin4;
        if (connector.switchChain)
          chain2 = await connector.switchChain(chainId2);
        else
          throw new ChainMismatchError({
            activeChain: (_connector$chains$fin = (_connector$chains$fin2 = connector.chains.find((x) => x.id === activeChainId)) === null || _connector$chains$fin2 === void 0 ? void 0 : _connector$chains$fin2.name) !== null && _connector$chains$fin !== void 0 ? _connector$chains$fin : "Chain ".concat(activeChainId),
            targetChain: (_connector$chains$fin3 = (_connector$chains$fin4 = connector.chains.find((x) => x.id === chainId2)) === null || _connector$chains$fin4 === void 0 ? void 0 : _connector$chains$fin4.name) !== null && _connector$chains$fin3 !== void 0 ? _connector$chains$fin3 : "Chain ".concat(chainId2)
          });
      }
    }
    const signer = await connector.getSigner({
      chainId: (_chain = chain2) === null || _chain === void 0 ? void 0 : _chain.id
    });
    return await signer.sendTransaction(request);
  } catch (error) {
    if (error.code === 4001)
      throw new UserRejectedRequestError(error);
    throw error;
  }
}
async function waitForTransaction(_ref) {
  let {
    chainId: chainId2,
    confirmations,
    hash,
    timeout,
    wait: wait_
  } = _ref;
  let promise;
  if (hash) {
    const provider = getProvider({
      chainId: chainId2
    });
    promise = provider.waitForTransaction(hash, confirmations, timeout);
  } else if (wait_)
    promise = wait_(confirmations);
  else
    throw new Error("hash or wait is required");
  return await promise;
}

// node_modules/wagmi/dist/wagmi.esm.js
var React11 = __toESM(require_react());

// node_modules/react-query/lib/core/subscribable.mjs
var Subscribable = class {
  constructor() {
    this.listeners = [];
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.push(listener);
    this.onSubscribe();
    return () => {
      this.listeners = this.listeners.filter((x) => x !== listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.length > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};

// node_modules/react-query/lib/core/utils.mjs
var isServer = typeof window === "undefined";
function noop() {
  return void 0;
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function parseQueryArgs(arg1, arg2, arg3) {
  if (!isQueryKey(arg1)) {
    return arg1;
  }
  if (typeof arg2 === "function") {
    return {
      ...arg3,
      queryKey: arg1,
      queryFn: arg2
    };
  }
  return {
    ...arg2,
    queryKey: arg1
  };
}
function parseMutationArgs(arg1, arg2, arg3) {
  if (isQueryKey(arg1)) {
    if (typeof arg2 === "function") {
      return {
        ...arg3,
        mutationKey: arg1,
        mutationFn: arg2
      };
    }
    return {
      ...arg2,
      mutationKey: arg1
    };
  }
  if (typeof arg1 === "function") {
    return {
      ...arg2,
      mutationFn: arg1
    };
  }
  return {
    ...arg1
  };
}
function parseFilterArgs(arg1, arg2, arg3) {
  return isQueryKey(arg1) ? [{
    ...arg2,
    queryKey: arg1
  }, arg3] : [arg1 || {}, arg2];
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey: queryKey2,
    stale
  } = filters;
  if (isQueryKey(queryKey2)) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey2, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey2)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (typeof fetchStatus !== "undefined" && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const {
    exact,
    fetching,
    predicate,
    mutationKey: mutationKey2
  } = filters;
  if (isQueryKey(mutationKey2)) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey2)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey2)) {
      return false;
    }
  }
  if (typeof fetching === "boolean" && mutation.state.status === "loading" !== fetching) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey2, options) {
  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;
  return hashFn(queryKey2);
}
function hashQueryKey(queryKey2) {
  return JSON.stringify(queryKey2, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
    result[key] = val[key];
    return result;
  }, {}) : val);
}
function partialMatchKey(a, b) {
  return partialDeepEqual(a, b);
}
function partialDeepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (a && b && typeof a === "object" && typeof b === "object") {
    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]));
  }
  return false;
}
function replaceEqualDeep(a, b) {
  if (a === b) {
    return a;
  }
  const array = isPlainArray(a) && isPlainArray(b);
  if (array || isPlainObject(a) && isPlainObject(b)) {
    const aSize = array ? a.length : Object.keys(a).length;
    const bItems = array ? b : Object.keys(b);
    const bSize = bItems.length;
    const copy = array ? [] : {};
    let equalItems = 0;
    for (let i = 0; i < bSize; i++) {
      const key = array ? i : bItems[i];
      copy[key] = replaceEqualDeep(a[key], b[key]);
      if (copy[key] === a[key]) {
        equalItems++;
      }
    }
    return aSize === bSize && equalItems === aSize ? a : copy;
  }
  return b;
}
function shallowEqualObjects(a, b) {
  if (a && !b || b && !a) {
    return false;
  }
  for (const key in a) {
    if (a[key] !== b[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (typeof ctor === "undefined") {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function isQueryKey(value) {
  return Array.isArray(value);
}
function sleep(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}
function scheduleMicrotask(callback) {
  sleep(0).then(callback);
}
function getAbortController() {
  if (typeof AbortController === "function") {
    return new AbortController();
  }
}
function replaceData(prevData, data, options) {
  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {
    return prevData;
  } else if (options.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data);
  }
  return data;
}

// node_modules/react-query/lib/core/focusManager.mjs
var FocusManager = class extends Subscribable {
  constructor() {
    super();
    this.setup = (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        window.addEventListener("focus", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
          window.removeEventListener("focus", listener);
        };
      }
    };
  }
  onSubscribe() {
    if (!this.cleanup) {
      this.setEventListener(this.setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$cleanup;
      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
      this.cleanup = void 0;
    }
  }
  setEventListener(setup) {
    var _this$cleanup2;
    this.setup = setup;
    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
    this.cleanup = setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    });
  }
  setFocused(focused) {
    this.focused = focused;
    if (focused) {
      this.onFocus();
    }
  }
  onFocus() {
    this.listeners.forEach((listener) => {
      listener();
    });
  }
  isFocused() {
    if (typeof this.focused === "boolean") {
      return this.focused;
    }
    if (typeof document === "undefined") {
      return true;
    }
    return [void 0, "visible", "prerender"].includes(document.visibilityState);
  }
};
var focusManager = new FocusManager();

// node_modules/react-query/lib/core/onlineManager.mjs
var OnlineManager = class extends Subscribable {
  constructor() {
    super();
    this.setup = (onOnline) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onOnline();
        window.addEventListener("online", listener, false);
        window.addEventListener("offline", listener, false);
        return () => {
          window.removeEventListener("online", listener);
          window.removeEventListener("offline", listener);
        };
      }
    };
  }
  onSubscribe() {
    if (!this.cleanup) {
      this.setEventListener(this.setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$cleanup;
      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
      this.cleanup = void 0;
    }
  }
  setEventListener(setup) {
    var _this$cleanup2;
    this.setup = setup;
    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
    this.cleanup = setup((online) => {
      if (typeof online === "boolean") {
        this.setOnline(online);
      } else {
        this.onOnline();
      }
    });
  }
  setOnline(online) {
    this.online = online;
    if (online) {
      this.onOnline();
    }
  }
  onOnline() {
    this.listeners.forEach((listener) => {
      listener();
    });
  }
  isOnline() {
    if (typeof this.online === "boolean") {
      return this.online;
    }
    if (typeof navigator === "undefined" || typeof navigator.onLine === "undefined") {
      return true;
    }
    return navigator.onLine;
  }
};
var onlineManager = new OnlineManager();

// node_modules/react-query/lib/core/retryer.mjs
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode != null ? networkMode : "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class {
  constructor(options) {
    this.revert = options == null ? void 0 : options.revert;
    this.silent = options == null ? void 0 : options.silent;
  }
};
function isCancelledError(value) {
  return value instanceof CancelledError;
}
function createRetryer(config) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  let promiseResolve;
  let promiseReject;
  const promise = new Promise((outerResolve, outerReject) => {
    promiseResolve = outerResolve;
    promiseReject = outerReject;
  });
  const cancel = (cancelOptions) => {
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      config.abort == null ? void 0 : config.abort();
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== "always" && !onlineManager.isOnline();
  const resolve = (value) => {
    if (!isResolved) {
      isResolved = true;
      config.onSuccess == null ? void 0 : config.onSuccess(value);
      continueFn == null ? void 0 : continueFn();
      promiseResolve(value);
    }
  };
  const reject = (value) => {
    if (!isResolved) {
      isResolved = true;
      config.onError == null ? void 0 : config.onError(value);
      continueFn == null ? void 0 : continueFn();
      promiseReject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      continueFn = (value) => {
        if (isResolved || !shouldPause()) {
          return continueResolve(value);
        }
      };
      config.onPause == null ? void 0 : config.onPause();
    }).then(() => {
      continueFn = void 0;
      if (!isResolved) {
        config.onContinue == null ? void 0 : config.onContinue();
      }
    });
  };
  const run = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    try {
      promiseOrValue = config.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      var _config$retry, _config$retryDelay;
      if (isResolved) {
        return;
      }
      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;
      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;
      const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      config.onFail == null ? void 0 : config.onFail(failureCount, error);
      sleep(delay).then(() => {
        if (shouldPause()) {
          return pause();
        }
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  if (canFetch(config.networkMode)) {
    run();
  } else {
    pause().then(run);
  }
  return {
    promise,
    cancel,
    continue: () => {
      continueFn == null ? void 0 : continueFn();
    },
    cancelRetry,
    continueRetry
  };
}

// node_modules/react-query/lib/core/logger.mjs
var defaultLogger = console;

// node_modules/react-query/lib/core/notifyManager.mjs
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  const batch = (callback) => {
    let result;
    transactions++;
    try {
      result = callback();
    } finally {
      transactions--;
      if (!transactions) {
        flush();
      }
    }
    return result;
  };
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleMicrotask(() => {
        notifyFn(callback);
      });
    }
  };
  const batchCalls = (callback) => {
    return (...args) => {
      schedule(() => {
        callback(...args);
      });
    };
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleMicrotask(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  const setNotifyFunction = (fn) => {
    notifyFn = fn;
  };
  const setBatchNotifyFunction = (fn) => {
    batchNotifyFn = fn;
  };
  return {
    batch,
    batchCalls,
    schedule,
    setNotifyFunction,
    setBatchNotifyFunction
  };
}
var notifyManager = createNotifyManager();

// node_modules/react-query/lib/core/removable.mjs
var Removable = class {
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.cacheTime)) {
      this.gcTimeout = setTimeout(() => {
        this.optionalRemove();
      }, this.cacheTime);
    }
  }
  updateCacheTime(newCacheTime) {
    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1e3);
  }
  clearGcTimeout() {
    clearTimeout(this.gcTimeout);
    this.gcTimeout = void 0;
  }
};

// node_modules/react-query/lib/core/query.mjs
var Query = class extends Removable {
  constructor(config) {
    super();
    this.abortSignalConsumed = false;
    this.defaultOptions = config.defaultOptions;
    this.setOptions(config.options);
    this.observers = [];
    this.cache = config.cache;
    this.logger = config.logger || defaultLogger;
    this.queryKey = config.queryKey;
    this.queryHash = config.queryHash;
    this.initialState = config.state || getDefaultState(this.options);
    this.state = this.initialState;
    this.meta = config.meta;
  }
  setOptions(options) {
    this.options = {
      ...this.defaultOptions,
      ...options
    };
    this.meta = options == null ? void 0 : options.meta;
    this.updateCacheTime(this.options.cacheTime);
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      this.cache.remove(this);
    }
  }
  setData(newData, options) {
    const data = replaceData(this.state.data, newData, this.options);
    this.dispatch({
      data,
      type: "success",
      dataUpdatedAt: options == null ? void 0 : options.updatedAt,
      manual: options == null ? void 0 : options.manual
    });
    return data;
  }
  setState(state, setStateOptions) {
    this.dispatch({
      type: "setState",
      state,
      setStateOptions
    });
  }
  cancel(options) {
    var _this$retryer;
    const promise = this.promise;
    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);
    return promise ? promise.then(noop).catch(noop) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({
      silent: true
    });
  }
  reset() {
    this.destroy();
    this.setState(this.initialState);
  }
  isActive() {
    return this.observers.some((observer) => observer.options.enabled !== false);
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some((observer) => observer.getCurrentResult().isStale);
  }
  isStaleByTime(staleTime = 0) {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    var _this$retryer2;
    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());
    if (observer) {
      observer.refetch({
        cancelRefetch: false
      });
    }
    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();
  }
  onOnline() {
    var _this$retryer3;
    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());
    if (observer) {
      observer.refetch({
        cancelRefetch: false
      });
    }
    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();
  }
  addObserver(observer) {
    if (this.observers.indexOf(observer) === -1) {
      this.observers.push(observer);
      this.clearGcTimeout();
      this.cache.notify({
        type: "observerAdded",
        query: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    if (this.observers.indexOf(observer) !== -1) {
      this.observers = this.observers.filter((x) => x !== observer);
      if (!this.observers.length) {
        if (this.retryer) {
          if (this.abortSignalConsumed) {
            this.retryer.cancel({
              revert: true
            });
          } else {
            this.retryer.cancelRetry();
          }
        }
        this.scheduleGc();
      }
      this.cache.notify({
        type: "observerRemoved",
        query: this,
        observer
      });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      this.dispatch({
        type: "invalidate"
      });
    }
  }
  fetch(options, fetchOptions) {
    var _this$options$behavio, _context$fetchOptions;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {
        this.cancel({
          silent: true
        });
      } else if (this.promise) {
        var _this$retryer4;
        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry();
        return this.promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x) => x.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    if (!Array.isArray(this.options.queryKey)) {
      if (true) {
        this.logger.error("As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']");
      }
    }
    const abortController = getAbortController();
    const queryFnContext = {
      queryKey: this.queryKey,
      pageParam: void 0,
      meta: this.meta
    };
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          if (abortController) {
            this.abortSignalConsumed = true;
            return abortController.signal;
          }
          return void 0;
        }
      });
    };
    addSignalProperty(queryFnContext);
    const fetchFn = () => {
      if (!this.options.queryFn) {
        return Promise.reject("Missing queryFn");
      }
      this.abortSignalConsumed = false;
      return this.options.queryFn(queryFnContext);
    };
    const context = {
      fetchOptions,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn,
      meta: this.meta
    };
    addSignalProperty(context);
    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context);
    this.revertState = this.state;
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {
      var _context$fetchOptions2;
      this.dispatch({
        type: "fetch",
        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta
      });
    }
    const onError = (error) => {
      if (!(isCancelledError(error) && error.silent)) {
        this.dispatch({
          type: "error",
          error
        });
      }
      if (!isCancelledError(error)) {
        var _this$cache$config$on, _this$cache$config;
        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);
        if (true) {
          this.logger.error(error);
        }
      }
      if (!this.isFetchingOptimistic) {
        this.scheduleGc();
      }
      this.isFetchingOptimistic = false;
    };
    this.retryer = createRetryer({
      fn: context.fetchFn,
      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),
      onSuccess: (data) => {
        var _this$cache$config$on2, _this$cache$config2;
        if (typeof data === "undefined") {
          onError(new Error("Query data cannot be undefined"));
          return;
        }
        this.setData(data);
        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, data, this);
        if (!this.isFetchingOptimistic) {
          this.scheduleGc();
        }
        this.isFetchingOptimistic = false;
      },
      onError,
      onFail: () => {
        this.dispatch({
          type: "failed"
        });
      },
      onPause: () => {
        this.dispatch({
          type: "pause"
        });
      },
      onContinue: () => {
        this.dispatch({
          type: "continue"
        });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode
    });
    this.promise = this.retryer.promise;
    return this.promise;
  }
  dispatch(action) {
    const reducer = (state) => {
      var _action$meta, _action$dataUpdatedAt;
      switch (action.type) {
        case "failed":
          return {
            ...state,
            fetchFailureCount: state.fetchFailureCount + 1
          };
        case "pause":
          return {
            ...state,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...state,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...state,
            fetchFailureCount: 0,
            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,
            fetchStatus: canFetch(this.options.networkMode) ? "fetching" : "paused",
            ...!state.dataUpdatedAt && {
              error: null,
              status: "loading"
            }
          };
        case "success":
          return {
            ...state,
            data: action.data,
            dataUpdateCount: state.dataUpdateCount + 1,
            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),
            error: null,
            isInvalidated: false,
            status: "success",
            ...!action.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0
            }
          };
        case "error":
          const error = action.error;
          if (isCancelledError(error) && error.revert && this.revertState) {
            return {
              ...this.revertState
            };
          }
          return {
            ...state,
            error,
            errorUpdateCount: state.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: state.fetchFailureCount + 1,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...state,
            isInvalidated: true
          };
        case "setState":
          return {
            ...state,
            ...action.state
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onQueryUpdate(action);
      });
      this.cache.notify({
        query: this,
        type: "updated",
        action
      });
    });
  }
};
function getDefaultState(options) {
  const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasInitialData = typeof options.initialData !== "undefined";
  const initialDataUpdatedAt = hasInitialData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  const hasData = typeof data !== "undefined";
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "loading",
    fetchStatus: "idle"
  };
}

// node_modules/react-query/lib/core/queryCache.mjs
var QueryCache = class extends Subscribable {
  constructor(config) {
    super();
    this.config = config || {};
    this.queries = [];
    this.queriesMap = {};
  }
  build(client2, options, state) {
    var _options$queryHash;
    const queryKey2 = options.queryKey;
    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey2, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        cache: this,
        logger: client2.getLogger(),
        queryKey: queryKey2,
        queryHash,
        options: client2.defaultQueryOptions(options),
        state,
        defaultOptions: client2.getQueryDefaults(queryKey2),
        meta: options.meta
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!this.queriesMap[query.queryHash]) {
      this.queriesMap[query.queryHash] = query;
      this.queries.push(query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = this.queriesMap[query.queryHash];
    if (queryInMap) {
      query.destroy();
      this.queries = this.queries.filter((x) => x !== query);
      if (queryInMap === query) {
        delete this.queriesMap[query.queryHash];
      }
      this.notify({
        type: "removed",
        query
      });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return this.queriesMap[queryHash];
  }
  getAll() {
    return this.queries;
  }
  find(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    if (typeof filters.exact === "undefined") {
      filters.exact = true;
    }
    return this.queries.find((query) => matchQuery(filters, query));
  }
  findAll(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    return Object.keys(filters).length > 0 ? this.queries.filter((query) => matchQuery(filters, query)) : this.queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        query.onOnline();
      });
    });
  }
};

// node_modules/react-query/lib/core/mutation.mjs
var Mutation = class extends Removable {
  constructor(config) {
    super();
    this.options = {
      ...config.defaultOptions,
      ...config.options
    };
    this.mutationId = config.mutationId;
    this.mutationCache = config.mutationCache;
    this.logger = config.logger || defaultLogger;
    this.observers = [];
    this.state = config.state || getDefaultState2();
    this.meta = config.meta;
    this.updateCacheTime(this.options.cacheTime);
    this.scheduleGc();
  }
  setState(state) {
    this.dispatch({
      type: "setState",
      state
    });
  }
  addObserver(observer) {
    if (this.observers.indexOf(observer) === -1) {
      this.observers.push(observer);
      this.clearGcTimeout();
      this.mutationCache.notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    this.observers = this.observers.filter((x) => x !== observer);
    this.scheduleGc();
    this.mutationCache.notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!this.observers.length) {
      if (this.state.status === "loading") {
        this.scheduleGc();
      } else {
        this.mutationCache.remove(this);
      }
    }
  }
  continue() {
    if (this.retryer) {
      this.retryer.continue();
      return this.retryer.promise;
    }
    return this.execute();
  }
  async execute() {
    const executeMutation = () => {
      var _this$options$retry;
      this.retryer = createRetryer({
        fn: () => {
          if (!this.options.mutationFn) {
            return Promise.reject("No mutationFn found");
          }
          return this.options.mutationFn(this.state.variables);
        },
        onFail: () => {
          this.dispatch({
            type: "failed"
          });
        },
        onPause: () => {
          this.dispatch({
            type: "pause"
          });
        },
        onContinue: () => {
          this.dispatch({
            type: "continue"
          });
        },
        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode
      });
      return this.retryer.promise;
    };
    const restored = this.state.status === "loading";
    try {
      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$options$onSettl, _this$options3;
      if (!restored) {
        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;
        this.dispatch({
          type: "loading",
          variables: this.options.variables
        });
        (_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this);
        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));
        if (context !== this.state.context) {
          this.dispatch({
            type: "loading",
            context,
            variables: this.state.variables
          });
        }
      }
      const data = await executeMutation();
      (_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this);
      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context));
      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));
      this.dispatch({
        type: "success",
        data
      });
      return data;
    } catch (error) {
      try {
        var _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onError, _this$options4, _this$options$onSettl2, _this$options5;
        (_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, error, this.state.variables, this.state.context, this);
        if (true) {
          this.logger.error(error);
        }
        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));
        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, void 0, error, this.state.variables, this.state.context));
        throw error;
      } finally {
        this.dispatch({
          type: "error",
          error
        });
      }
    }
  }
  dispatch(action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            failureCount: state.failureCount + 1
          };
        case "pause":
          return {
            ...state,
            isPaused: true
          };
        case "continue":
          return {
            ...state,
            isPaused: false
          };
        case "loading":
          return {
            ...state,
            context: action.context,
            data: void 0,
            error: null,
            isPaused: !canFetch(this.options.networkMode),
            status: "loading",
            variables: action.variables
          };
        case "success":
          return {
            ...state,
            data: action.data,
            error: null,
            status: "success",
            isPaused: false
          };
        case "error":
          return {
            ...state,
            data: void 0,
            error: action.error,
            failureCount: state.failureCount + 1,
            isPaused: false,
            status: "error"
          };
        case "setState":
          return {
            ...state,
            ...action.state
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onMutationUpdate(action);
      });
      this.mutationCache.notify({
        mutation: this,
        type: "updated",
        action
      });
    });
  }
};
function getDefaultState2() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    isPaused: false,
    status: "idle",
    variables: void 0
  };
}

// node_modules/react-query/lib/core/mutationCache.mjs
var MutationCache = class extends Subscribable {
  constructor(config) {
    super();
    this.config = config || {};
    this.mutations = [];
    this.mutationId = 0;
  }
  build(client2, options, state) {
    const mutation = new Mutation({
      mutationCache: this,
      logger: client2.getLogger(),
      mutationId: ++this.mutationId,
      options: client2.defaultMutationOptions(options),
      state,
      defaultOptions: options.mutationKey ? client2.getMutationDefaults(options.mutationKey) : void 0,
      meta: options.meta
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    this.mutations.push(mutation);
    this.notify({
      type: "added",
      mutation
    });
  }
  remove(mutation) {
    this.mutations = this.mutations.filter((x) => x !== mutation);
    this.notify({
      type: "removed",
      mutation
    });
  }
  clear() {
    notifyManager.batch(() => {
      this.mutations.forEach((mutation) => {
        this.remove(mutation);
      });
    });
  }
  getAll() {
    return this.mutations;
  }
  find(filters) {
    if (typeof filters.exact === "undefined") {
      filters.exact = true;
    }
    return this.mutations.find((mutation) => matchMutation(filters, mutation));
  }
  findAll(filters) {
    return this.mutations.filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.mutations.filter((x) => x.state.isPaused);
    return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));
  }
};

// node_modules/react-query/lib/core/infiniteQueryBehavior.mjs
function infiniteQueryBehavior() {
  return {
    onFetch: (context) => {
      context.fetchFn = () => {
        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;
        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;
        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;
        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;
        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === "forward";
        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === "backward";
        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];
        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];
        let newPageParams = oldPageParams;
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              var _context$signal;
              if ((_context$signal = context.signal) != null && _context$signal.aborted) {
                cancelled = true;
              } else {
                var _context$signal2;
                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn2 = context.options.queryFn || (() => Promise.reject("Missing queryFn"));
        const buildNewPages = (pages, param, page, previous) => {
          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];
          return previous ? [page, ...pages] : [...pages, page];
        };
        const fetchPage = (pages, manual, param, previous) => {
          if (cancelled) {
            return Promise.reject("Cancelled");
          }
          if (typeof param === "undefined" && !manual && pages.length) {
            return Promise.resolve(pages);
          }
          const queryFnContext = {
            queryKey: context.queryKey,
            pageParam: param,
            meta: context.meta
          };
          addSignalProperty(queryFnContext);
          const queryFnResult = queryFn2(queryFnContext);
          const promise2 = Promise.resolve(queryFnResult).then((page) => buildNewPages(pages, param, page, previous));
          return promise2;
        };
        let promise;
        if (!oldPages.length) {
          promise = fetchPage([]);
        } else if (isFetchingNextPage) {
          const manual = typeof pageParam !== "undefined";
          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);
          promise = fetchPage(oldPages, manual, param);
        } else if (isFetchingPreviousPage) {
          const manual = typeof pageParam !== "undefined";
          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);
          promise = fetchPage(oldPages, manual, param, true);
        } else {
          newPageParams = [];
          const manual = typeof context.options.getNextPageParam === "undefined";
          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true;
          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]));
          for (let i = 1; i < oldPages.length; i++) {
            promise = promise.then((pages) => {
              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;
              if (shouldFetchNextPage) {
                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);
                return fetchPage(pages, manual, param);
              }
              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));
            });
          }
        }
        const finalPromise = promise.then((pages) => ({
          pages,
          pageParams: newPageParams
        }));
        return finalPromise;
      };
    }
  };
}
function getNextPageParam(options, pages) {
  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);
}
function getPreviousPageParam(options, pages) {
  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);
}
function hasNextPage(options, pages) {
  if (options.getNextPageParam && Array.isArray(pages)) {
    const nextPageParam = getNextPageParam(options, pages);
    return typeof nextPageParam !== "undefined" && nextPageParam !== null && nextPageParam !== false;
  }
}
function hasPreviousPage(options, pages) {
  if (options.getPreviousPageParam && Array.isArray(pages)) {
    const previousPageParam = getPreviousPageParam(options, pages);
    return typeof previousPageParam !== "undefined" && previousPageParam !== null && previousPageParam !== false;
  }
}

// node_modules/react-query/lib/core/queryClient.mjs
var QueryClient = class {
  constructor(config = {}) {
    this.queryCache = config.queryCache || new QueryCache();
    this.mutationCache = config.mutationCache || new MutationCache();
    this.logger = config.logger || defaultLogger;
    this.defaultOptions = config.defaultOptions || {};
    this.queryDefaults = [];
    this.mutationDefaults = [];
  }
  mount() {
    this.unsubscribeFocus = focusManager.subscribe(() => {
      if (focusManager.isFocused()) {
        this.resumePausedMutations();
        this.queryCache.onFocus();
      }
    });
    this.unsubscribeOnline = onlineManager.subscribe(() => {
      if (onlineManager.isOnline()) {
        this.resumePausedMutations();
        this.queryCache.onOnline();
      }
    });
  }
  unmount() {
    var _this$unsubscribeFocu, _this$unsubscribeOnli;
    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);
    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);
  }
  isFetching(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    filters.fetchStatus = "fetching";
    return this.queryCache.findAll(filters).length;
  }
  isMutating(filters) {
    return this.mutationCache.findAll({
      ...filters,
      fetching: true
    }).length;
  }
  getQueryData(queryKey2, filters) {
    var _this$queryCache$find;
    return (_this$queryCache$find = this.queryCache.find(queryKey2, filters)) == null ? void 0 : _this$queryCache$find.state.data;
  }
  getQueriesData(queryKeyOrFilters) {
    return this.getQueryCache().findAll(queryKeyOrFilters).map(({
      queryKey: queryKey2,
      state
    }) => {
      const data = state.data;
      return [queryKey2, data];
    });
  }
  setQueryData(queryKey2, updater, options) {
    const query = this.queryCache.find(queryKey2);
    const prevData = query == null ? void 0 : query.state.data;
    const data = functionalUpdate(updater, prevData);
    if (typeof data === "undefined") {
      return void 0;
    }
    const parsedOptions = parseQueryArgs(queryKey2);
    const defaultedOptions = this.defaultQueryOptions(parsedOptions);
    return this.queryCache.build(this, defaultedOptions).setData(data, {
      ...options,
      manual: true
    });
  }
  setQueriesData(queryKeyOrFilters, updater, options) {
    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({
      queryKey: queryKey2
    }) => [queryKey2, this.setQueryData(queryKey2, updater, options)]));
  }
  getQueryState(queryKey2, filters) {
    var _this$queryCache$find2;
    return (_this$queryCache$find2 = this.queryCache.find(queryKey2, filters)) == null ? void 0 : _this$queryCache$find2.state;
  }
  removeQueries(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    const queryCache = this.queryCache;
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(arg1, arg2, arg3) {
    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
    const queryCache = this.queryCache;
    const refetchFilters = {
      type: "active",
      ...filters
    };
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(refetchFilters, options);
    });
  }
  cancelQueries(arg1, arg2, arg3) {
    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);
    if (typeof cancelOptions.revert === "undefined") {
      cancelOptions.revert = true;
    }
    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map((query) => query.cancel(cancelOptions)));
    return Promise.all(promises).then(noop).catch(noop);
  }
  invalidateQueries(arg1, arg2, arg3) {
    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
    return notifyManager.batch(() => {
      var _ref, _filters$refetchType;
      this.queryCache.findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters.refetchType === "none") {
        return Promise.resolve();
      }
      const refetchFilters = {
        ...filters,
        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : "active"
      };
      return this.refetchQueries(refetchFilters, options);
    });
  }
  refetchQueries(arg1, arg2, arg3) {
    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
      var _options$cancelRefetc;
      return query.fetch(void 0, {
        ...options,
        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,
        meta: {
          refetchPage: filters.refetchPage
        }
      });
    }));
    let promise = Promise.all(promises).then(noop);
    if (!(options != null && options.throwOnError)) {
      promise = promise.catch(noop);
    }
    return promise;
  }
  fetchQuery(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
    const defaultedOptions = this.defaultQueryOptions(parsedOptions);
    if (typeof defaultedOptions.retry === "undefined") {
      defaultedOptions.retry = false;
    }
    const query = this.queryCache.build(this, defaultedOptions);
    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(arg1, arg2, arg3) {
    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);
  }
  fetchInfiniteQuery(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
    parsedOptions.behavior = infiniteQueryBehavior();
    return this.fetchQuery(parsedOptions);
  }
  prefetchInfiniteQuery(arg1, arg2, arg3) {
    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);
  }
  resumePausedMutations() {
    return this.mutationCache.resumePausedMutations();
  }
  getQueryCache() {
    return this.queryCache;
  }
  getMutationCache() {
    return this.mutationCache;
  }
  getLogger() {
    return this.logger;
  }
  getDefaultOptions() {
    return this.defaultOptions;
  }
  setDefaultOptions(options) {
    this.defaultOptions = options;
  }
  setQueryDefaults(queryKey2, options) {
    const result = this.queryDefaults.find((x) => hashQueryKey(queryKey2) === hashQueryKey(x.queryKey));
    if (result) {
      result.defaultOptions = options;
    } else {
      this.queryDefaults.push({
        queryKey: queryKey2,
        defaultOptions: options
      });
    }
  }
  getQueryDefaults(queryKey2) {
    if (!queryKey2) {
      return void 0;
    }
    const firstMatchingDefaults = this.queryDefaults.find((x) => partialMatchKey(queryKey2, x.queryKey));
    if (true) {
      const matchingDefaults = this.queryDefaults.filter((x) => partialMatchKey(queryKey2, x.queryKey));
      if (matchingDefaults.length > 1) {
        if (true) {
          this.logger.error("[QueryClient] Several query defaults match with key '" + JSON.stringify(queryKey2) + "'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.");
        }
      }
    }
    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
  }
  setMutationDefaults(mutationKey2, options) {
    const result = this.mutationDefaults.find((x) => hashQueryKey(mutationKey2) === hashQueryKey(x.mutationKey));
    if (result) {
      result.defaultOptions = options;
    } else {
      this.mutationDefaults.push({
        mutationKey: mutationKey2,
        defaultOptions: options
      });
    }
  }
  getMutationDefaults(mutationKey2) {
    if (!mutationKey2) {
      return void 0;
    }
    const firstMatchingDefaults = this.mutationDefaults.find((x) => partialMatchKey(mutationKey2, x.mutationKey));
    if (true) {
      const matchingDefaults = this.mutationDefaults.filter((x) => partialMatchKey(mutationKey2, x.mutationKey));
      if (matchingDefaults.length > 1) {
        if (true) {
          this.logger.error("[QueryClient] Several mutation defaults match with key '" + JSON.stringify(mutationKey2) + "'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.");
        }
      }
    }
    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
  }
  defaultQueryOptions(options) {
    if (options != null && options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...this.defaultOptions.queries,
      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);
    }
    if (typeof defaultedOptions.refetchOnReconnect === "undefined") {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (typeof defaultedOptions.useErrorBoundary === "undefined") {
      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options != null && options._defaulted) {
      return options;
    }
    return {
      ...this.defaultOptions.mutations,
      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    this.queryCache.clear();
    this.mutationCache.clear();
  }
};

// node_modules/react-query/lib/core/queryObserver.mjs
var QueryObserver = class extends Subscribable {
  constructor(client2, options) {
    super();
    this.client = client2;
    this.options = options;
    this.trackedProps = /* @__PURE__ */ new Set();
    this.selectError = null;
    this.bindMethods();
    this.setOptions(options);
  }
  bindMethods() {
    this.remove = this.remove.bind(this);
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.length === 1) {
      this.currentQuery.addObserver(this);
      if (shouldFetchOnMount(this.currentQuery, this.options)) {
        this.executeFetch();
      }
      this.updateTimers();
    }
  }
  onUnsubscribe() {
    if (!this.listeners.length) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
  }
  destroy() {
    this.listeners = [];
    this.clearStaleTimeout();
    this.clearRefetchInterval();
    this.currentQuery.removeObserver(this);
  }
  setOptions(options, notifyOptions) {
    const prevOptions = this.options;
    const prevQuery = this.currentQuery;
    this.options = this.client.defaultQueryOptions(options);
    if (typeof this.options.enabled !== "undefined" && typeof this.options.enabled !== "boolean") {
      throw new Error("Expected enabled to be a boolean");
    }
    if (!this.options.queryKey) {
      this.options.queryKey = prevOptions.queryKey;
    }
    this.updateQuery();
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {
      this.executeFetch();
    }
    this.updateResult(notifyOptions);
    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
      this.updateStaleTimeout();
    }
    const nextRefetchInterval = this.computeRefetchInterval();
    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {
      this.updateRefetchInterval(nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = this.client.getQueryCache().build(this.client, options);
    return this.createResult(query, options);
  }
  getCurrentResult() {
    return this.currentResult;
  }
  trackResult(result) {
    const trackedResult = {};
    Object.keys(result).forEach((key) => {
      Object.defineProperty(trackedResult, key, {
        configurable: false,
        enumerable: true,
        get: () => {
          this.trackedProps.add(key);
          return result[key];
        }
      });
    });
    return trackedResult;
  }
  getCurrentQuery() {
    return this.currentQuery;
  }
  remove() {
    this.client.getQueryCache().remove(this.currentQuery);
  }
  refetch({
    refetchPage,
    ...options
  } = {}) {
    return this.fetch({
      ...options,
      meta: {
        refetchPage
      }
    });
  }
  fetchOptimistic(options) {
    const defaultedOptions = this.client.defaultQueryOptions(options);
    const query = this.client.getQueryCache().build(this.client, defaultedOptions);
    query.isFetchingOptimistic = true;
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    var _fetchOptions$cancelR;
    return this.executeFetch({
      ...fetchOptions,
      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true
    }).then(() => {
      this.updateResult();
      return this.currentResult;
    });
  }
  executeFetch(fetchOptions) {
    this.updateQuery();
    let promise = this.currentQuery.fetch(this.options, fetchOptions);
    if (!(fetchOptions != null && fetchOptions.throwOnError)) {
      promise = promise.catch(noop);
    }
    return promise;
  }
  updateStaleTimeout() {
    this.clearStaleTimeout();
    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {
      return;
    }
    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime);
    const timeout = time + 1;
    this.staleTimeoutId = setTimeout(() => {
      if (!this.currentResult.isStale) {
        this.updateResult();
      }
    }, timeout);
  }
  computeRefetchInterval() {
    var _this$options$refetch;
    return typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;
  }
  updateRefetchInterval(nextInterval) {
    this.clearRefetchInterval();
    this.currentRefetchInterval = nextInterval;
    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {
      return;
    }
    this.refetchIntervalId = setInterval(() => {
      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
        this.executeFetch();
      }
    }, this.currentRefetchInterval);
  }
  updateTimers() {
    this.updateStaleTimeout();
    this.updateRefetchInterval(this.computeRefetchInterval());
  }
  clearStaleTimeout() {
    clearTimeout(this.staleTimeoutId);
    this.staleTimeoutId = void 0;
  }
  clearRefetchInterval() {
    clearInterval(this.refetchIntervalId);
    this.refetchIntervalId = void 0;
  }
  createResult(query, options) {
    const prevQuery = this.currentQuery;
    const prevOptions = this.options;
    const prevResult = this.currentResult;
    const prevResultState = this.currentResultState;
    const prevResultOptions = this.currentResultOptions;
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;
    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;
    const {
      state
    } = query;
    let {
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      fetchStatus,
      status
    } = state;
    let isPreviousData = false;
    let isPlaceholderData = false;
    let data;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        fetchStatus = canFetch(query.options.networkMode) ? "fetching" : "paused";
        if (!dataUpdatedAt) {
          status = "loading";
        }
      }
      if (options._optimisticResults === "isRestoring") {
        fetchStatus = "idle";
      }
    }
    if (options.keepPreviousData && !state.dataUpdateCount && prevQueryResult != null && prevQueryResult.isSuccess && status !== "error") {
      data = prevQueryResult.data;
      dataUpdatedAt = prevQueryResult.dataUpdatedAt;
      status = prevQueryResult.status;
      isPreviousData = true;
    } else if (options.select && typeof state.data !== "undefined") {
      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {
        data = this.selectResult;
      } else {
        try {
          this.selectFn = options.select;
          data = options.select(state.data);
          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);
          this.selectResult = data;
          this.selectError = null;
        } catch (selectError) {
          if (true) {
            this.client.getLogger().error(selectError);
          }
          this.selectError = selectError;
        }
      }
    } else {
      data = state.data;
    }
    if (typeof options.placeholderData !== "undefined" && typeof data === "undefined" && status === "loading") {
      let placeholderData;
      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
        placeholderData = prevResult.data;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData() : options.placeholderData;
        if (options.select && typeof placeholderData !== "undefined") {
          try {
            placeholderData = options.select(placeholderData);
            placeholderData = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);
            this.selectError = null;
          } catch (selectError) {
            if (true) {
              this.client.getLogger().error(selectError);
            }
            this.selectError = selectError;
          }
        }
      }
      if (typeof placeholderData !== "undefined") {
        status = "success";
        data = placeholderData;
        isPlaceholderData = true;
      }
    }
    if (this.selectError) {
      error = this.selectError;
      data = this.selectResult;
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = fetchStatus === "fetching";
    const result = {
      status,
      fetchStatus,
      isLoading: status === "loading",
      isSuccess: status === "success",
      isError: status === "error",
      data,
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: state.fetchFailureCount,
      errorUpdateCount: state.errorUpdateCount,
      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,
      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && status !== "loading",
      isLoadingError: status === "error" && state.dataUpdatedAt === 0,
      isPaused: fetchStatus === "paused",
      isPlaceholderData,
      isPreviousData,
      isRefetchError: status === "error" && state.dataUpdatedAt !== 0,
      isStale: isStale(query, options),
      refetch: this.refetch,
      remove: this.remove
    };
    return result;
  }
  updateResult(notifyOptions) {
    const prevResult = this.currentResult;
    const nextResult = this.createResult(this.currentQuery, this.options);
    this.currentResultState = this.currentQuery.state;
    this.currentResultOptions = this.options;
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    this.currentResult = nextResult;
    const defaultNotifyOptions = {
      cache: true
    };
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const {
        notifyOnChangeProps
      } = this.options;
      if (notifyOnChangeProps === "all" || !notifyOnChangeProps && !this.trackedProps.size) {
        return true;
      }
      const includedProps = new Set(notifyOnChangeProps != null ? notifyOnChangeProps : this.trackedProps);
      if (this.options.useErrorBoundary) {
        includedProps.add("error");
      }
      return Object.keys(this.currentResult).some((key) => {
        const typedKey = key;
        const changed = this.currentResult[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
      defaultNotifyOptions.listeners = true;
    }
    this.notify({
      ...defaultNotifyOptions,
      ...notifyOptions
    });
  }
  updateQuery() {
    const query = this.client.getQueryCache().build(this.client, this.options);
    if (query === this.currentQuery) {
      return;
    }
    const prevQuery = this.currentQuery;
    this.currentQuery = query;
    this.currentQueryInitialState = query.state;
    this.previousQueryResult = this.currentResult;
    if (this.hasListeners()) {
      prevQuery == null ? void 0 : prevQuery.removeObserver(this);
      query.addObserver(this);
    }
  }
  onQueryUpdate(action) {
    const notifyOptions = {};
    if (action.type === "success") {
      notifyOptions.onSuccess = !action.manual;
    } else if (action.type === "error" && !isCancelledError(action.error)) {
      notifyOptions.onError = true;
    }
    this.updateResult(notifyOptions);
    if (this.hasListeners()) {
      this.updateTimers();
    }
  }
  notify(notifyOptions) {
    notifyManager.batch(() => {
      if (notifyOptions.onSuccess) {
        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;
        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);
        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);
      } else if (notifyOptions.onError) {
        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;
        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);
        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, void 0, this.currentResult.error);
      }
      if (notifyOptions.listeners) {
        this.listeners.forEach((listener) => {
          listener(this.currentResult);
        });
      }
      if (notifyOptions.cache) {
        this.client.getQueryCache().notify({
          query: this.currentQuery,
          type: "observerResultsUpdated"
        });
      }
    });
  }
};
function shouldLoadOnMount(query, options) {
  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (options.enabled !== false) {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return query.isStaleByTime(options.staleTime);
}

// node_modules/react-query/lib/core/infiniteQueryObserver.mjs
var InfiniteQueryObserver = class extends QueryObserver {
  constructor(client2, options) {
    super(client2, options);
  }
  bindMethods() {
    super.bindMethods();
    this.fetchNextPage = this.fetchNextPage.bind(this);
    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
  }
  setOptions(options, notifyOptions) {
    super.setOptions({
      ...options,
      behavior: infiniteQueryBehavior()
    }, notifyOptions);
  }
  getOptimisticResult(options) {
    options.behavior = infiniteQueryBehavior();
    return super.getOptimisticResult(options);
  }
  fetchNextPage({
    pageParam,
    ...options
  } = {}) {
    return this.fetch({
      ...options,
      meta: {
        fetchMore: {
          direction: "forward",
          pageParam
        }
      }
    });
  }
  fetchPreviousPage({
    pageParam,
    ...options
  } = {}) {
    return this.fetch({
      ...options,
      meta: {
        fetchMore: {
          direction: "backward",
          pageParam
        }
      }
    });
  }
  createResult(query, options) {
    var _state$data, _state$data2, _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet;
    const {
      state
    } = query;
    const result = super.createResult(query, options);
    return {
      ...result,
      fetchNextPage: this.fetchNextPage,
      fetchPreviousPage: this.fetchPreviousPage,
      hasNextPage: hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),
      hasPreviousPage: hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),
      isFetchingNextPage: state.fetchStatus === "fetching" && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === "forward",
      isFetchingPreviousPage: state.fetchStatus === "fetching" && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === "backward"
    };
  }
};

// node_modules/react-query/lib/core/mutationObserver.mjs
var MutationObserver = class extends Subscribable {
  constructor(client2, options) {
    super();
    this.client = client2;
    this.setOptions(options);
    this.bindMethods();
    this.updateResult();
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    this.options = this.client.defaultMutationOptions(options);
  }
  onUnsubscribe() {
    if (!this.listeners.length) {
      var _this$currentMutation;
      (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    this.updateResult();
    const notifyOptions = {
      listeners: true
    };
    if (action.type === "success") {
      notifyOptions.onSuccess = true;
    } else if (action.type === "error") {
      notifyOptions.onError = true;
    }
    this.notify(notifyOptions);
  }
  getCurrentResult() {
    return this.currentResult;
  }
  reset() {
    this.currentMutation = void 0;
    this.updateResult();
    this.notify({
      listeners: true
    });
  }
  mutate(variables, options) {
    this.mutateOptions = options;
    if (this.currentMutation) {
      this.currentMutation.removeObserver(this);
    }
    this.currentMutation = this.client.getMutationCache().build(this.client, {
      ...this.options,
      variables: typeof variables !== "undefined" ? variables : this.options.variables
    });
    this.currentMutation.addObserver(this);
    return this.currentMutation.execute();
  }
  updateResult() {
    const state = this.currentMutation ? this.currentMutation.state : getDefaultState2();
    const result = {
      ...state,
      isLoading: state.status === "loading",
      isSuccess: state.status === "success",
      isError: state.status === "error",
      isIdle: state.status === "idle",
      mutate: this.mutate,
      reset: this.reset
    };
    this.currentResult = result;
  }
  notify(options) {
    notifyManager.batch(() => {
      if (this.mutateOptions) {
        if (options.onSuccess) {
          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;
          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);
          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);
        } else if (options.onError) {
          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;
          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, void 0, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
        }
      }
      if (options.listeners) {
        this.listeners.forEach((listener) => {
          listener(this.currentResult);
        });
      }
    });
  }
};

// node_modules/react-query/lib/core/hydration.mjs
function dehydrateMutation(mutation) {
  return {
    mutationKey: mutation.options.mutationKey,
    state: mutation.state
  };
}
function dehydrateQuery(query) {
  return {
    state: query.state,
    queryKey: query.queryKey,
    queryHash: query.queryHash
  };
}
function defaultShouldDehydrateMutation(mutation) {
  return mutation.state.isPaused;
}
function defaultShouldDehydrateQuery(query) {
  return query.state.status === "success";
}
function dehydrate(client2, options = {}) {
  const mutations = [];
  const queries = [];
  if (options.dehydrateMutations !== false) {
    const shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;
    client2.getMutationCache().getAll().forEach((mutation) => {
      if (shouldDehydrateMutation(mutation)) {
        mutations.push(dehydrateMutation(mutation));
      }
    });
  }
  if (options.dehydrateQueries !== false) {
    const shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;
    client2.getQueryCache().getAll().forEach((query) => {
      if (shouldDehydrateQuery(query)) {
        queries.push(dehydrateQuery(query));
      }
    });
  }
  return {
    mutations,
    queries
  };
}
function hydrate(client2, dehydratedState, options) {
  if (typeof dehydratedState !== "object" || dehydratedState === null) {
    return;
  }
  const mutationCache = client2.getMutationCache();
  const queryCache = client2.getQueryCache();
  const mutations = dehydratedState.mutations || [];
  const queries = dehydratedState.queries || [];
  mutations.forEach((dehydratedMutation) => {
    var _options$defaultOptio;
    mutationCache.build(client2, {
      ...options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations,
      mutationKey: dehydratedMutation.mutationKey
    }, dehydratedMutation.state);
  });
  queries.forEach((dehydratedQuery) => {
    var _options$defaultOptio2;
    const query = queryCache.get(dehydratedQuery.queryHash);
    if (query) {
      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {
        query.setState(dehydratedQuery.state);
      }
      return;
    }
    queryCache.build(client2, {
      ...options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries,
      queryKey: dehydratedQuery.queryKey,
      queryHash: dehydratedQuery.queryHash
    }, dehydratedQuery.state);
  });
}

// node_modules/react-query/lib/reactjs/reactBatchedUpdates.mjs
var import_react_dom = __toESM(require_react_dom(), 1);
var unstable_batchedUpdates = import_react_dom.default.unstable_batchedUpdates;

// node_modules/react-query/lib/reactjs/setBatchUpdatesFn.mjs
notifyManager.setBatchNotifyFunction(unstable_batchedUpdates);

// node_modules/react-query/lib/reactjs/QueryClientProvider.mjs
var import_react = __toESM(require_react(), 1);
var defaultContext = import_react.default.createContext(void 0);
var QueryClientSharingContext = import_react.default.createContext(false);
function getQueryClientContext(context, contextSharing) {
  if (context) {
    return context;
  }
  if (contextSharing && typeof window !== "undefined") {
    if (!window.ReactQueryClientContext) {
      window.ReactQueryClientContext = defaultContext;
    }
    return window.ReactQueryClientContext;
  }
  return defaultContext;
}
var useQueryClient = ({
  context
} = {}) => {
  const queryClient = import_react.default.useContext(getQueryClientContext(context, import_react.default.useContext(QueryClientSharingContext)));
  if (!queryClient) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return queryClient;
};
var QueryClientProvider = ({
  client: client2,
  children,
  context,
  contextSharing = false
}) => {
  import_react.default.useEffect(() => {
    client2.mount();
    return () => {
      client2.unmount();
    };
  }, [client2]);
  const Context2 = getQueryClientContext(context, contextSharing);
  return import_react.default.createElement(QueryClientSharingContext.Provider, {
    value: !context && contextSharing
  }, import_react.default.createElement(Context2.Provider, {
    value: client2
  }, children));
};

// node_modules/react-query/lib/reactjs/QueryErrorResetBoundary.mjs
var import_react2 = __toESM(require_react(), 1);
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = import_react2.default.createContext(createValue());
var useQueryErrorResetBoundary = () => import_react2.default.useContext(QueryErrorResetBoundaryContext);

// node_modules/react-query/lib/reactjs/useIsFetching.mjs
var import_react3 = __toESM(require_react(), 1);

// node_modules/react-query/lib/reactjs/useSyncExternalStore.mjs
var import_shim = __toESM(require_shim(), 1);
var useSyncExternalStore = import_shim.default.useSyncExternalStore;

// node_modules/react-query/lib/reactjs/useIsMutating.mjs
var import_react4 = __toESM(require_react(), 1);

// node_modules/react-query/lib/reactjs/useMutation.mjs
var import_react5 = __toESM(require_react(), 1);

// node_modules/react-query/lib/reactjs/utils.mjs
function shouldThrowError(_useErrorBoundary, params) {
  if (typeof _useErrorBoundary === "function") {
    return _useErrorBoundary(...params);
  }
  return !!_useErrorBoundary;
}

// node_modules/react-query/lib/reactjs/useMutation.mjs
function useMutation(arg1, arg2, arg3) {
  const options = parseMutationArgs(arg1, arg2, arg3);
  const queryClient = useQueryClient({
    context: options.context
  });
  const [observer] = import_react5.default.useState(() => new MutationObserver(queryClient, options));
  import_react5.default.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = useSyncExternalStore(import_react5.default.useCallback((onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
  const mutate = import_react5.default.useCallback((variables, mutateOptions) => {
    observer.mutate(variables, mutateOptions).catch(noop);
  }, [observer]);
  if (result.error && shouldThrowError(observer.options.useErrorBoundary, [result.error])) {
    throw result.error;
  }
  return {
    ...result,
    mutate,
    mutateAsync: result.mutate
  };
}

// node_modules/react-query/lib/reactjs/useBaseQuery.mjs
var import_react7 = __toESM(require_react(), 1);

// node_modules/react-query/lib/reactjs/isRestoring.mjs
var import_react6 = __toESM(require_react(), 1);
var IsRestoringContext = import_react6.default.createContext(false);
var useIsRestoring = () => import_react6.default.useContext(IsRestoringContext);
var IsRestoringProvider = IsRestoringContext.Provider;

// node_modules/react-query/lib/reactjs/useQueries.mjs
var import_react8 = __toESM(require_react(), 1);

// node_modules/react-query/lib/reactjs/Hydrate.mjs
var import_react9 = __toESM(require_react(), 1);

// node_modules/react-query/lib/persistQueryClient/persist.mjs
async function persistQueryClientRestore({
  queryClient,
  persister,
  maxAge = 1e3 * 60 * 60 * 24,
  buster = "",
  hydrateOptions
}) {
  try {
    const persistedClient = await persister.restoreClient();
    if (persistedClient) {
      if (persistedClient.timestamp) {
        const expired = Date.now() - persistedClient.timestamp > maxAge;
        const busted = persistedClient.buster !== buster;
        if (expired || busted) {
          persister.removeClient();
        } else {
          hydrate(queryClient, persistedClient.clientState, hydrateOptions);
        }
      } else {
        persister.removeClient();
      }
    }
  } catch (err) {
    if (true) {
      queryClient.getLogger().error(err);
      queryClient.getLogger().warn("Encountered an error attempting to restore client cache from persisted location. As a precaution, the persisted cache will be discarded.");
    }
    persister.removeClient();
  }
}
async function persistQueryClientSave({
  queryClient,
  persister,
  buster = "",
  dehydrateOptions
}) {
  const persistClient = {
    buster,
    timestamp: Date.now(),
    clientState: dehydrate(queryClient, dehydrateOptions)
  };
  await persister.persistClient(persistClient);
}
function persistQueryClientSubscribe(props) {
  const unsubscribeQueryCache = props.queryClient.getQueryCache().subscribe(() => {
    persistQueryClientSave(props);
  });
  const unusbscribeMutationCache = props.queryClient.getMutationCache().subscribe(() => {
    persistQueryClientSave(props);
  });
  return () => {
    unsubscribeQueryCache();
    unusbscribeMutationCache();
  };
}
function persistQueryClient(props) {
  let hasUnsubscribed = false;
  let persistQueryClientUnsubscribe;
  const unsubscribe = () => {
    hasUnsubscribed = true;
    persistQueryClientUnsubscribe == null ? void 0 : persistQueryClientUnsubscribe();
  };
  const restorePromise = persistQueryClientRestore(props).then(() => {
    if (!hasUnsubscribed) {
      persistQueryClientUnsubscribe = persistQueryClientSubscribe(props);
    }
  });
  return [unsubscribe, restorePromise];
}

// node_modules/react-query/lib/persistQueryClient/PersistQueryClientProvider.mjs
var import_react10 = __toESM(require_react(), 1);

// node_modules/react-query/lib/createWebStoragePersister/index.mjs
function createWebStoragePersister({
  storage,
  key = "REACT_QUERY_OFFLINE_CACHE",
  throttleTime = 1e3,
  serialize: serialize2 = JSON.stringify,
  deserialize: deserialize2 = JSON.parse,
  retry
}) {
  if (typeof storage !== "undefined") {
    const trySave = (persistedClient) => {
      try {
        storage.setItem(key, serialize2(persistedClient));
      } catch (error) {
        return error;
      }
    };
    return {
      persistClient: throttle((persistedClient) => {
        let client2 = persistedClient;
        let error = trySave(client2);
        let errorCount = 0;
        while (error && client2) {
          errorCount++;
          client2 = retry == null ? void 0 : retry({
            persistedClient: client2,
            error,
            errorCount
          });
          if (client2) {
            error = trySave(client2);
          }
        }
      }, throttleTime),
      restoreClient: () => {
        const cacheString = storage.getItem(key);
        if (!cacheString) {
          return;
        }
        return deserialize2(cacheString);
      },
      removeClient: () => {
        storage.removeItem(key);
      }
    };
  }
  return {
    persistClient: noop,
    restoreClient: noop,
    removeClient: noop
  };
}
function throttle(func, wait = 100) {
  let timer = null;
  let params;
  return function(...args) {
    params = args;
    if (timer === null) {
      timer = setTimeout(() => {
        func(...params);
        timer = null;
      }, wait);
    }
  };
}

// node_modules/wagmi/dist/wagmi.esm.js
var import_ethers4 = __toESM(require_ethers());
var pkg2 = __toESM(require_shim());
var import_with_selector = __toESM(require_with_selector());
var findAndReplace = (cacheRef, _ref) => {
  let {
    find,
    replace
  } = _ref;
  if (cacheRef && find(cacheRef)) {
    return replace(cacheRef);
  }
  if (typeof cacheRef !== "object") {
    return cacheRef;
  }
  if (Array.isArray(cacheRef)) {
    return cacheRef.map((item) => findAndReplace(item, {
      find,
      replace
    }));
  }
  if (cacheRef instanceof Object) {
    return Object.entries(cacheRef).reduce((curr, _ref2) => {
      let [key, value] = _ref2;
      return {
        ...curr,
        [key]: findAndReplace(value, {
          find,
          replace
        })
      };
    }, {});
  }
  return cacheRef;
};
function deserialize(cachedString) {
  const cache = JSON.parse(cachedString);
  const deserializedCacheWithBigNumbers = findAndReplace(cache, {
    find: (data) => data.type === "BigNumber",
    replace: (data) => import_ethers4.BigNumber.from(data.hex)
  });
  return deserializedCacheWithBigNumbers;
}
function isPlainArray2(value) {
  return Array.isArray(value) && Object.keys(value).length === value.length;
}
function parseContractResult(_ref) {
  let {
    contractInterface,
    data,
    functionName
  } = _ref;
  if (data && isPlainArray2(data)) {
    var _fragment$outputs, _fragment$outputs$, _fragment$outputs2, _fragment$outputs2$;
    const iface = import_ethers4.Contract.getInterface(contractInterface);
    const fragment = iface.getFunction(functionName);
    const isArray = (fragment === null || fragment === void 0 ? void 0 : (_fragment$outputs = fragment.outputs) === null || _fragment$outputs === void 0 ? void 0 : (_fragment$outputs$ = _fragment$outputs[0]) === null || _fragment$outputs$ === void 0 ? void 0 : _fragment$outputs$.baseType) === "array" || (fragment === null || fragment === void 0 ? void 0 : (_fragment$outputs2 = fragment.outputs) === null || _fragment$outputs2 === void 0 ? void 0 : (_fragment$outputs2$ = _fragment$outputs2[0]) === null || _fragment$outputs2$ === void 0 ? void 0 : _fragment$outputs2$.baseType) === "tuple";
    const data_ = isArray ? [data] : data;
    const encodedResult = iface.encodeFunctionResult(functionName, data_);
    const decodedResult = iface.decodeFunctionResult(functionName, encodedResult);
    return isArray ? decodedResult[0] : decodedResult;
  }
  return data;
}
function getReferenceKey(keys, cutoff) {
  return keys.slice(0, cutoff).join(".") || ".";
}
function getCutoff(array, value) {
  const {
    length
  } = array;
  for (let index = 0; index < length; ++index) {
    if (array[index] === value) {
      return index + 1;
    }
  }
  return 0;
}
function createReplacer(replacer, circularReplacer) {
  const hasReplacer = typeof replacer === "function";
  const hasCircularReplacer = typeof circularReplacer === "function";
  const cache = [];
  const keys = [];
  return function replace(key, value) {
    if (typeof value === "object") {
      if (cache.length) {
        const thisCutoff = getCutoff(cache, this);
        if (thisCutoff === 0) {
          cache[cache.length] = this;
        } else {
          cache.splice(thisCutoff);
          keys.splice(thisCutoff);
        }
        keys[keys.length] = key;
        const valueCutoff = getCutoff(cache, value);
        if (valueCutoff !== 0) {
          return hasCircularReplacer ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff)) : "[ref=".concat(getReferenceKey(keys, valueCutoff), "]");
        }
      } else {
        cache[0] = value;
        keys[0] = key;
      }
    }
    return hasReplacer ? replacer.call(this, key, value) : value;
  };
}
function serialize(value, replacer, indent, circularReplacer) {
  return JSON.stringify(value, createReplacer(replacer, circularReplacer), indent !== null && indent !== void 0 ? indent : void 0);
}
function createClient2(_ref) {
  let {
    queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          cacheTime: 1e3 * 60 * 60 * 24,
          networkMode: "offlineFirst",
          refetchOnWindowFocus: false,
          retry: 0
        },
        mutations: {
          networkMode: "offlineFirst"
        }
      }
    }),
    persister = typeof window !== "undefined" ? createWebStoragePersister({
      key: "wagmi.cache",
      storage: window.localStorage,
      serialize,
      deserialize
    }) : void 0,
    ...config
  } = _ref;
  const client2 = createClient(config);
  if (persister)
    persistQueryClient({
      queryClient,
      persister,
      dehydrateOptions: {
        shouldDehydrateQuery: (query) => query.cacheTime !== 0
      }
    });
  return Object.assign(client2, {
    queryClient
  });
}
var Context = React11.createContext(void 0);
function WagmiConfig(_ref2) {
  let {
    children,
    client: client2
  } = _ref2;
  React11.useEffect(() => {
    (async () => {
      if (!client2.config.autoConnect)
        return;
      await client2.autoConnect();
    })();
  }, []);
  return React11.createElement(Context.Provider, {
    value: client2
  }, React11.createElement(QueryClientProvider, {
    client: client2.queryClient
  }, children));
}
function useClient() {
  const client2 = React11.useContext(Context);
  if (!client2)
    throw new Error(["`useClient` must be used within `WagmiConfig`.\n", "Read more: https://wagmi.sh/docs/WagmiConfig"].join("\n"));
  return client2;
}
var useSyncExternalStore3 = pkg2.useSyncExternalStore;
function isQueryKey2(value) {
  return Array.isArray(value);
}
function parseQueryArgs2(arg1, arg2, arg3) {
  if (!isQueryKey2(arg1)) {
    return arg1;
  }
  if (typeof arg2 === "function") {
    return {
      ...arg3,
      queryKey: arg1,
      queryFn: arg2
    };
  }
  return {
    ...arg2,
    queryKey: arg1
  };
}
function shouldThrowError2(_useErrorBoundary, params) {
  if (typeof _useErrorBoundary === "function") {
    return _useErrorBoundary(...params);
  }
  return !!_useErrorBoundary;
}
function trackResult(result, observer) {
  const trackedResult = {};
  Object.keys(result).forEach((key) => {
    Object.defineProperty(trackedResult, key, {
      configurable: false,
      enumerable: true,
      get: () => {
        observer.trackedProps.add(key);
        return result[key];
      }
    });
  });
  return trackedResult;
}
function useBaseQuery2(options, Observer) {
  const queryClient = useQueryClient({
    context: options.context
  });
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedOptions = queryClient.defaultQueryOptions(options);
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  if (defaultedOptions.onError) {
    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);
  }
  if (defaultedOptions.onSuccess) {
    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);
  }
  if (defaultedOptions.onSettled) {
    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);
  }
  if (defaultedOptions.suspense) {
    if (typeof defaultedOptions.staleTime !== "number") {
      defaultedOptions.staleTime = 1e3;
    }
  }
  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {
    if (!errorResetBoundary.isReset()) {
      defaultedOptions.retryOnMount = false;
    }
  }
  const [observer] = React11.useState(() => new Observer(queryClient, defaultedOptions));
  const result = observer.getOptimisticResult(defaultedOptions);
  useSyncExternalStore3(React11.useCallback((onStoreChange) => isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
  React11.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
  React11.useEffect(() => {
    observer.setOptions(defaultedOptions, {
      listeners: false
    });
  }, [defaultedOptions, observer]);
  if (defaultedOptions.suspense && result.isLoading && result.isFetching && !isRestoring) {
    throw observer.fetchOptimistic(defaultedOptions).then((_ref) => {
      var _defaultedOptions$onS, _defaultedOptions$onS2;
      let {
        data
      } = _ref;
      (_defaultedOptions$onS = defaultedOptions.onSuccess) === null || _defaultedOptions$onS === void 0 ? void 0 : _defaultedOptions$onS.call(defaultedOptions, data);
      (_defaultedOptions$onS2 = defaultedOptions.onSettled) === null || _defaultedOptions$onS2 === void 0 ? void 0 : _defaultedOptions$onS2.call(defaultedOptions, data, null);
    }).catch((error) => {
      var _defaultedOptions$onE, _defaultedOptions$onS3;
      errorResetBoundary.clearReset();
      (_defaultedOptions$onE = defaultedOptions.onError) === null || _defaultedOptions$onE === void 0 ? void 0 : _defaultedOptions$onE.call(defaultedOptions, error);
      (_defaultedOptions$onS3 = defaultedOptions.onSettled) === null || _defaultedOptions$onS3 === void 0 ? void 0 : _defaultedOptions$onS3.call(defaultedOptions, void 0, error);
    });
  }
  if (result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError2(defaultedOptions.useErrorBoundary, [result.error, observer.getCurrentQuery()])) {
    throw result.error;
  }
  const status = result.status === "loading" && result.fetchStatus === "idle" ? "idle" : result.status;
  const isIdle = status === "idle";
  const isLoading = status === "loading" && result.fetchStatus === "fetching";
  return {
    ...result,
    defaultedOptions,
    isIdle,
    isLoading,
    observer,
    status
  };
}
function useInfiniteQuery2(arg1, arg2, arg3) {
  const parsedOptions = parseQueryArgs2(arg1, arg2, arg3);
  const baseQuery = useBaseQuery2(parsedOptions, InfiniteQueryObserver);
  const result = {
    data: baseQuery.data,
    error: baseQuery.error,
    fetchNextPage: baseQuery.fetchNextPage,
    fetchStatus: baseQuery.fetchStatus,
    hasNextPage: baseQuery.hasNextPage,
    isError: baseQuery.isError,
    isFetched: baseQuery.isFetched,
    isFetching: baseQuery.isFetching,
    isFetchingNextPage: baseQuery.isFetchingNextPage,
    isIdle: baseQuery.isIdle,
    isLoading: baseQuery.isLoading,
    isRefetching: baseQuery.isRefetching,
    isSuccess: baseQuery.isSuccess,
    refetch: baseQuery.refetch,
    status: baseQuery.status,
    internal: {
      dataUpdatedAt: baseQuery.dataUpdatedAt,
      errorUpdatedAt: baseQuery.errorUpdatedAt,
      failureCount: baseQuery.failureCount,
      isFetchedAfterMount: baseQuery.isFetchedAfterMount,
      isLoadingError: baseQuery.isLoadingError,
      isPaused: baseQuery.isPaused,
      isPlaceholderData: baseQuery.isPlaceholderData,
      isPreviousData: baseQuery.isPreviousData,
      isRefetchError: baseQuery.isRefetchError,
      isStale: baseQuery.isStale,
      remove: baseQuery.remove
    }
  };
  return !baseQuery.defaultedOptions.notifyOnChangeProps ? trackResult(result, baseQuery.observer) : result;
}
function useQuery2(arg1, arg2, arg3) {
  const parsedOptions = parseQueryArgs2(arg1, arg2, arg3);
  const baseQuery = useBaseQuery2(parsedOptions, QueryObserver);
  const result = {
    data: baseQuery.data,
    error: baseQuery.error,
    fetchStatus: baseQuery.fetchStatus,
    isError: baseQuery.isError,
    isFetched: baseQuery.isFetched,
    isFetching: baseQuery.isFetching,
    isIdle: baseQuery.isIdle,
    isLoading: baseQuery.isLoading,
    isRefetching: baseQuery.isRefetching,
    isSuccess: baseQuery.isSuccess,
    refetch: baseQuery.refetch,
    status: baseQuery.status,
    internal: {
      dataUpdatedAt: baseQuery.dataUpdatedAt,
      errorUpdatedAt: baseQuery.errorUpdatedAt,
      failureCount: baseQuery.failureCount,
      isFetchedAfterMount: baseQuery.isFetchedAfterMount,
      isLoadingError: baseQuery.isLoadingError,
      isPaused: baseQuery.isPaused,
      isPlaceholderData: baseQuery.isPlaceholderData,
      isPreviousData: baseQuery.isPreviousData,
      isRefetchError: baseQuery.isRefetchError,
      isStale: baseQuery.isStale,
      remove: baseQuery.remove
    }
  };
  return !baseQuery.defaultedOptions.notifyOnChangeProps ? trackResult(result, baseQuery.observer) : result;
}
function useProvider() {
  let {
    chainId: chainId2
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const forceUpdate = useForceUpdate();
  const client2 = useClient();
  const provider = React11.useRef(getProvider({
    chainId: chainId2
  }));
  React11.useEffect(() => {
    const unwatch = watchProvider({
      chainId: chainId2
    }, (provider_) => {
      provider.current = provider_;
      forceUpdate();
    });
    return unwatch;
  }, [chainId2, client2, forceUpdate]);
  return provider.current;
}
function useWebSocketProvider() {
  let {
    chainId: chainId2
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const forceUpdate = useForceUpdate();
  const client2 = useClient();
  const webSocketProvider = React11.useRef(getWebSocketProvider({
    chainId: chainId2
  }));
  React11.useEffect(() => {
    const unwatch = watchWebSocketProvider({
      chainId: chainId2
    }, (webSocketProvider_) => {
      webSocketProvider.current = webSocketProvider_;
      forceUpdate();
    });
    return unwatch;
  }, [chainId2, client2, forceUpdate]);
  return webSocketProvider.current;
}
function useChainId() {
  let {
    chainId: chainId2
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const provider = useProvider({
    chainId: chainId2
  });
  return provider.network.chainId;
}
function useForceUpdate() {
  const [, forceUpdate] = React11.useReducer((x) => x + 1, 0);
  return forceUpdate;
}
var queryKey$c = (_ref) => {
  let {
    chainId: chainId2
  } = _ref;
  return [{
    entity: "blockNumber",
    chainId: chainId2
  }];
};
var queryFn$c = (_ref2) => {
  let {
    queryKey: [{
      chainId: chainId2
    }]
  } = _ref2;
  return fetchBlockNumber({
    chainId: chainId2
  });
};
function useBlockNumber() {
  let {
    cacheTime = 0,
    chainId: chainId_,
    enabled = true,
    staleTime,
    suspense,
    watch = false,
    onBlock,
    onError,
    onSettled,
    onSuccess
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const chainId2 = useChainId({
    chainId: chainId_
  });
  const provider = useProvider();
  const webSocketProvider = useWebSocketProvider();
  const queryClient = useQueryClient();
  React11.useEffect(() => {
    if (!watch && !onBlock)
      return;
    const listener = (blockNumber) => {
      if (watch)
        queryClient.setQueryData(queryKey$c({
          chainId: chainId2
        }), blockNumber);
      if (onBlock)
        onBlock(blockNumber);
    };
    const provider_ = webSocketProvider !== null && webSocketProvider !== void 0 ? webSocketProvider : provider;
    provider_.on("block", listener);
    return () => {
      provider_.off("block", listener);
    };
  }, [chainId2, onBlock, provider, queryClient, watch, webSocketProvider]);
  return useQuery2(queryKey$c({
    chainId: chainId2
  }), queryFn$c, {
    cacheTime,
    enabled,
    staleTime,
    suspense,
    onError,
    onSettled,
    onSuccess
  });
}
var queryKey$b = (_ref) => {
  let {
    chainId: chainId2,
    formatUnits: formatUnits2
  } = _ref;
  return [{
    entity: "feeData",
    chainId: chainId2,
    formatUnits: formatUnits2
  }];
};
var queryFn$b = (_ref2) => {
  let {
    queryKey: [{
      chainId: chainId2,
      formatUnits: formatUnits2
    }]
  } = _ref2;
  return fetchFeeData({
    chainId: chainId2,
    formatUnits: formatUnits2
  });
};
function useFeeData() {
  let {
    cacheTime,
    chainId: chainId_,
    enabled = true,
    formatUnits: formatUnits2 = "wei",
    staleTime,
    suspense,
    watch,
    onError,
    onSettled,
    onSuccess
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const chainId2 = useChainId({
    chainId: chainId_
  });
  const feeDataQuery = useQuery2(queryKey$b({
    chainId: chainId2,
    formatUnits: formatUnits2
  }), queryFn$b, {
    cacheTime,
    enabled,
    staleTime,
    suspense,
    onError,
    onSettled,
    onSuccess
  });
  const {
    data: blockNumber
  } = useBlockNumber({
    watch
  });
  React11.useEffect(() => {
    if (!enabled)
      return;
    if (!watch)
      return;
    if (!blockNumber)
      return;
    feeDataQuery.refetch();
  }, [blockNumber]);
  return feeDataQuery;
}
function useInvalidateOnBlock(_ref) {
  let {
    enabled,
    queryKey: queryKey2
  } = _ref;
  const queryClient = useQueryClient();
  useBlockNumber({
    onBlock: enabled ? () => queryClient.invalidateQueries(queryKey2) : void 0
  });
}
var isPlainObject2 = (obj) => typeof obj === "object" && !Array.isArray(obj);
function useSyncExternalStoreWithTracked(subscribe, getSnapshot) {
  let getServerSnapshot = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : getSnapshot;
  let isEqual = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (a, b) => deepEqual(a, b);
  const trackedKeys = React11.useRef([]);
  const result = (0, import_with_selector.useSyncExternalStoreWithSelector)(subscribe, getSnapshot, getServerSnapshot, (x) => x, (a, b) => {
    if (isPlainObject2(a) && isPlainObject2(b)) {
      for (const key of trackedKeys.current) {
        const equal = isEqual(a[key], b[key]);
        if (!equal)
          return false;
      }
      return true;
    }
    return isEqual(a, b);
  });
  if (isPlainObject2(result)) {
    const trackedResult = {
      ...result
    };
    Object.defineProperties(trackedResult, Object.entries(trackedResult).reduce((res, _ref) => {
      let [key, value] = _ref;
      return {
        ...res,
        [key]: {
          configurable: false,
          enumerable: true,
          get: () => {
            if (!trackedKeys.current.includes(key)) {
              trackedKeys.current.push(key);
            }
            return value;
          }
        }
      };
    }, {}));
    return trackedResult;
  }
  return result;
}
function useAccount() {
  let {
    onConnect,
    onDisconnect
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const account = useSyncExternalStoreWithTracked(watchAccount, getAccount);
  const {
    subscribe
  } = useClient();
  React11.useEffect(() => {
    if (!onConnect && !onDisconnect)
      return;
    const unsubscribe = subscribe((state) => state.status, (status, prevStatus) => {
      if (!!onConnect && status === "connected") {
        const {
          address,
          connector
        } = getAccount();
        onConnect({
          address,
          connector,
          isReconnected: prevStatus === "reconnecting"
        });
      }
      if (!!onDisconnect && prevStatus !== "connecting" && status === "disconnected")
        onDisconnect();
    });
    return unsubscribe;
  }, [onConnect, onDisconnect, subscribe]);
  return account;
}
var queryKey$a = (_ref) => {
  let {
    addressOrName,
    chainId: chainId2,
    formatUnits: formatUnits2,
    token
  } = _ref;
  return [{
    entity: "balance",
    addressOrName,
    chainId: chainId2,
    formatUnits: formatUnits2,
    token
  }];
};
var queryFn$a = (_ref2) => {
  let {
    queryKey: [{
      addressOrName,
      chainId: chainId2,
      formatUnits: formatUnits2,
      token
    }]
  } = _ref2;
  if (!addressOrName)
    throw new Error("address is required");
  return fetchBalance({
    addressOrName,
    chainId: chainId2,
    formatUnits: formatUnits2,
    token
  });
};
function useBalance() {
  let {
    addressOrName,
    cacheTime,
    chainId: chainId_,
    enabled = true,
    formatUnits: formatUnits2 = "ether",
    staleTime,
    suspense,
    token,
    watch,
    onError,
    onSettled,
    onSuccess
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const chainId2 = useChainId({
    chainId: chainId_
  });
  const balanceQuery = useQuery2(queryKey$a({
    addressOrName,
    chainId: chainId2,
    formatUnits: formatUnits2,
    token
  }), queryFn$a, {
    cacheTime,
    enabled: Boolean(enabled && addressOrName),
    staleTime,
    suspense,
    onError,
    onSettled,
    onSuccess
  });
  const {
    data: blockNumber
  } = useBlockNumber({
    watch
  });
  React11.useEffect(() => {
    if (!enabled)
      return;
    if (!watch)
      return;
    if (!blockNumber)
      return;
    if (!addressOrName)
      return;
    balanceQuery.refetch();
  }, [blockNumber]);
  return balanceQuery;
}
var mutationKey$6 = (args) => [{
  entity: "connect",
  ...args
}];
var mutationFn$5 = (args) => {
  const {
    connector,
    chainId: chainId2
  } = args;
  if (!connector)
    throw new Error("connector is required");
  return connect({
    connector,
    chainId: chainId2
  });
};
function useConnect() {
  let {
    chainId: chainId2,
    connector,
    onError,
    onMutate,
    onSettled,
    onSuccess
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const client2 = useClient();
  const {
    data,
    error,
    isError: isError2,
    isIdle,
    isLoading,
    isSuccess,
    mutate,
    mutateAsync,
    reset,
    status,
    variables
  } = useMutation(mutationKey$6({
    connector,
    chainId: chainId2
  }), mutationFn$5, {
    onError,
    onMutate,
    onSettled,
    onSuccess
  });
  const connect2 = React11.useCallback((args) => {
    var _args$chainId, _args$connector;
    return mutate({
      chainId: (_args$chainId = args === null || args === void 0 ? void 0 : args.chainId) !== null && _args$chainId !== void 0 ? _args$chainId : chainId2,
      connector: (_args$connector = args === null || args === void 0 ? void 0 : args.connector) !== null && _args$connector !== void 0 ? _args$connector : connector
    });
  }, [chainId2, connector, mutate]);
  const connectAsync = React11.useCallback((args) => {
    var _args$chainId2, _args$connector2;
    return mutateAsync({
      chainId: (_args$chainId2 = args === null || args === void 0 ? void 0 : args.chainId) !== null && _args$chainId2 !== void 0 ? _args$chainId2 : chainId2,
      connector: (_args$connector2 = args === null || args === void 0 ? void 0 : args.connector) !== null && _args$connector2 !== void 0 ? _args$connector2 : connector
    });
  }, [chainId2, connector, mutateAsync]);
  return {
    connect: connect2,
    connectAsync,
    connectors: client2.connectors,
    data,
    error,
    isError: isError2,
    isIdle,
    isLoading,
    isSuccess,
    pendingConnector: variables === null || variables === void 0 ? void 0 : variables.connector,
    reset,
    status,
    variables
  };
}
var mutationKey$5 = [{
  entity: "disconnect"
}];
var mutationFn$4 = () => disconnect();
function useDisconnect() {
  let {
    onError,
    onMutate,
    onSettled,
    onSuccess
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    error,
    isError: isError2,
    isIdle,
    isLoading,
    isSuccess,
    mutate: disconnect2,
    mutateAsync: disconnectAsync,
    reset,
    status
  } = useMutation(mutationKey$5, mutationFn$4, {
    ...onError ? {
      onError(error2, _variables, context) {
        onError(error2, context);
      }
    } : {},
    onMutate,
    ...onSettled ? {
      onSettled(_data, error2, _variables, context) {
        onSettled(error2, context);
      }
    } : {},
    ...onSuccess ? {
      onSuccess(_data, _variables, context) {
        onSuccess(context);
      }
    } : {}
  });
  return {
    disconnect: disconnect2,
    disconnectAsync,
    error,
    isError: isError2,
    isIdle,
    isLoading,
    isSuccess,
    reset,
    status
  };
}
function useNetwork() {
  return useSyncExternalStoreWithTracked(watchNetwork, getNetwork);
}
var queryKey$9 = () => [{
  entity: "signer"
}];
var queryFn$9 = () => fetchSigner();
function useSigner() {
  let {
    suspense,
    onError,
    onSettled,
    onSuccess
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const signerQuery = useQuery2(queryKey$9(), queryFn$9, {
    cacheTime: 0,
    staleTime: 0,
    suspense,
    onError,
    onSettled,
    onSuccess
  });
  const queryClient = useQueryClient();
  React11.useEffect(() => {
    const unwatch = watchSigner((signer) => queryClient.setQueryData(queryKey$9(), signer));
    return unwatch;
  }, [queryClient]);
  return signerQuery;
}
var mutationKey$4 = (args) => [{
  entity: "signMessage",
  ...args
}];
var mutationFn$3 = (args) => {
  const {
    message
  } = args;
  if (!message)
    throw new Error("message is required");
  return signMessage({
    message
  });
};
function useSignMessage() {
  let {
    message,
    onError,
    onMutate,
    onSettled,
    onSuccess
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    data,
    error,
    isError: isError2,
    isIdle,
    isLoading,
    isSuccess,
    mutate,
    mutateAsync,
    reset,
    status,
    variables
  } = useMutation(mutationKey$4({
    message
  }), mutationFn$3, {
    onError,
    onMutate,
    onSettled,
    onSuccess
  });
  const signMessage2 = React11.useCallback((args) => mutate(args || {
    message
  }), [message, mutate]);
  const signMessageAsync = React11.useCallback((args) => mutateAsync(args || {
    message
  }), [message, mutateAsync]);
  return {
    data,
    error,
    isError: isError2,
    isIdle,
    isLoading,
    isSuccess,
    reset,
    signMessage: signMessage2,
    signMessageAsync,
    status,
    variables
  };
}
var mutationKey$3 = (args) => [{
  entity: "signTypedData",
  ...args
}];
var mutationFn$2 = (args) => {
  const {
    domain,
    types,
    value
  } = args;
  if (!domain || !types || !value)
    throw new Error("domain, types, and value are all required");
  return signTypedData({
    domain,
    types,
    value
  });
};
function useSignTypedData() {
  let {
    domain,
    types,
    value,
    onError,
    onMutate,
    onSettled,
    onSuccess
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    data,
    error,
    isError: isError2,
    isIdle,
    isLoading,
    isSuccess,
    mutate,
    mutateAsync,
    reset,
    status,
    variables
  } = useMutation(mutationKey$3({
    domain,
    types,
    value
  }), mutationFn$2, {
    onError,
    onMutate,
    onSettled,
    onSuccess
  });
  const signTypedData2 = React11.useCallback((args) => mutate(args || {
    domain,
    types,
    value
  }), [domain, types, value, mutate]);
  const signTypedDataAsync = React11.useCallback((args) => mutateAsync(args || {
    domain,
    types,
    value
  }), [domain, types, value, mutateAsync]);
  return {
    data,
    error,
    isError: isError2,
    isIdle,
    isLoading,
    isSuccess,
    reset,
    signTypedData: signTypedData2,
    signTypedDataAsync,
    status,
    variables
  };
}
var mutationKey$2 = (args) => [{
  entity: "switchNetwork",
  ...args
}];
var mutationFn$1 = (args) => {
  const {
    chainId: chainId2
  } = args;
  if (!chainId2)
    throw new Error("chainId is required");
  return switchNetwork({
    chainId: chainId2
  });
};
function useSwitchNetwork() {
  var _client$connector, _client$chains;
  let {
    chainId: chainId2,
    throwForSwitchChainNotSupported,
    onError,
    onMutate,
    onSettled,
    onSuccess
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const client2 = useClient();
  const forceUpdate = useForceUpdate();
  const {
    data,
    error,
    isError: isError2,
    isIdle,
    isLoading,
    isSuccess,
    mutate,
    mutateAsync,
    reset,
    status,
    variables
  } = useMutation(mutationKey$2({
    chainId: chainId2
  }), mutationFn$1, {
    onError,
    onMutate,
    onSettled,
    onSuccess
  });
  const switchNetwork_ = React11.useCallback((chainId_) => mutate({
    chainId: chainId_ !== null && chainId_ !== void 0 ? chainId_ : chainId2
  }), [chainId2, mutate]);
  const switchNetworkAsync_ = React11.useCallback((chainId_) => mutateAsync({
    chainId: chainId_ !== null && chainId_ !== void 0 ? chainId_ : chainId2
  }), [chainId2, mutateAsync]);
  React11.useEffect(() => {
    const unwatch = client2.subscribe((_ref) => {
      let {
        chains,
        connector
      } = _ref;
      return {
        chains,
        connector
      };
    }, forceUpdate);
    return unwatch;
  }, [client2, forceUpdate]);
  let switchNetwork2;
  let switchNetworkAsync;
  const supportsSwitchChain = !!((_client$connector = client2.connector) !== null && _client$connector !== void 0 && _client$connector.switchChain);
  if (throwForSwitchChainNotSupported || supportsSwitchChain) {
    switchNetwork2 = switchNetwork_;
    switchNetworkAsync = switchNetworkAsync_;
  }
  return {
    chains: (_client$chains = client2.chains) !== null && _client$chains !== void 0 ? _client$chains : [],
    data,
    error,
    isError: isError2,
    isIdle,
    isLoading,
    isSuccess,
    pendingChainId: variables === null || variables === void 0 ? void 0 : variables.chainId,
    reset,
    status,
    switchNetwork: switchNetwork2,
    switchNetworkAsync,
    variables
  };
}
var useContract = (_ref) => {
  let {
    addressOrName,
    contractInterface,
    signerOrProvider
  } = _ref;
  return React11.useMemo(() => {
    return getContract({
      addressOrName,
      contractInterface,
      signerOrProvider
    });
  }, [addressOrName, contractInterface, signerOrProvider]);
};
var useContractEvent = (_ref) => {
  var _ref2;
  let {
    addressOrName,
    chainId: chainId2,
    contractInterface,
    listener,
    eventName,
    signerOrProvider,
    once
  } = _ref;
  const provider = useProvider({
    chainId: chainId2
  });
  const webSocketProvider = useWebSocketProvider({
    chainId: chainId2
  });
  const contract = useContract({
    addressOrName,
    contractInterface,
    signerOrProvider: (_ref2 = webSocketProvider !== null && webSocketProvider !== void 0 ? webSocketProvider : provider) !== null && _ref2 !== void 0 ? _ref2 : signerOrProvider
  });
  const listenerRef = React11.useRef(listener);
  listenerRef.current = listener;
  React11.useEffect(() => {
    const handler = function() {
      for (var _len = arguments.length, event = new Array(_len), _key = 0; _key < _len; _key++) {
        event[_key] = arguments[_key];
      }
      return listenerRef.current(event);
    };
    const contract_ = contract;
    if (once)
      contract_.once(eventName, handler);
    else
      contract_.on(eventName, handler);
    return () => {
      contract_.off(eventName, handler);
    };
  }, [contract, eventName]);
};
var paginatedIndexesConfig = (fn, _ref) => {
  let {
    perPage,
    start,
    direction
  } = _ref;
  return {
    getNextPageParam: (lastPage, pages) => (lastPage === null || lastPage === void 0 ? void 0 : lastPage.length) === perPage ? pages.length : void 0,
    contracts: function() {
      let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return [...Array(perPage).keys()].map((index) => {
        return direction === "increment" ? start + index + page * perPage : start - index - page * perPage;
      }).filter((index) => index >= 0).map(fn);
    }
  };
};
var queryKey$8 = (_ref2) => {
  let [{
    cacheKey,
    overrides
  }] = _ref2;
  return [{
    entity: "readContractsInfinite",
    cacheKey,
    overrides
  }];
};
var queryFn$8 = (_ref3) => {
  let {
    contracts
  } = _ref3;
  return (_ref4) => {
    let {
      queryKey: [{
        overrides
      }],
      pageParam
    } = _ref4;
    return readContracts({
      contracts: contracts(pageParam || void 0),
      overrides
    });
  };
};
function useContractInfiniteReads(_ref5) {
  let {
    cacheKey,
    cacheTime,
    contracts,
    enabled: enabled_ = true,
    getNextPageParam: getNextPageParam2,
    isDataEqual = deepEqual,
    keepPreviousData,
    onError,
    onSettled,
    onSuccess,
    overrides,
    select,
    staleTime,
    suspense
  } = _ref5;
  const queryKey_ = React11.useMemo(() => queryKey$8([{
    cacheKey,
    overrides
  }]), [cacheKey, overrides]);
  const enabled = React11.useMemo(() => {
    const enabled2 = Boolean(enabled_ && contracts);
    return enabled2;
  }, [contracts, enabled_]);
  return useInfiniteQuery2(queryKey_, queryFn$8({
    contracts
  }), {
    cacheTime,
    enabled,
    getNextPageParam: getNextPageParam2,
    isDataEqual,
    keepPreviousData,
    select,
    staleTime,
    suspense,
    onError,
    onSettled,
    onSuccess
  });
}
var queryKey$7 = (_ref) => {
  let [{
    addressOrName,
    args,
    chainId: chainId2,
    contractInterface,
    functionName,
    overrides
  }, {
    blockNumber
  }] = _ref;
  return [{
    entity: "readContract",
    addressOrName,
    args,
    blockNumber,
    chainId: chainId2,
    contractInterface,
    functionName,
    overrides
  }];
};
var queryKeyHashFn$1 = (_ref2) => {
  let [queryKey_] = _ref2;
  const {
    contractInterface,
    ...rest
  } = queryKey_;
  return hashQueryKey([rest]);
};
var queryFn$7 = (_ref3) => {
  let {
    queryKey: [{
      addressOrName,
      args,
      chainId: chainId2,
      contractInterface,
      functionName,
      overrides
    }]
  } = _ref3;
  return readContract({
    addressOrName,
    args,
    chainId: chainId2,
    contractInterface,
    functionName,
    overrides
  });
};
function useContractRead(_ref4) {
  let {
    addressOrName,
    contractInterface,
    functionName,
    args,
    chainId: chainId_,
    overrides,
    cacheOnBlock = false,
    cacheTime,
    enabled: enabled_ = true,
    isDataEqual = deepEqual,
    select,
    staleTime,
    suspense,
    watch,
    onError,
    onSettled,
    onSuccess
  } = _ref4;
  const chainId2 = useChainId({
    chainId: chainId_
  });
  const {
    data: blockNumber
  } = useBlockNumber({
    enabled: watch || cacheOnBlock,
    watch
  });
  const queryKey_ = React11.useMemo(() => queryKey$7([{
    addressOrName,
    args,
    chainId: chainId2,
    contractInterface,
    functionName,
    overrides
  }, {
    blockNumber: cacheOnBlock ? blockNumber : void 0
  }]), [addressOrName, args, blockNumber, cacheOnBlock, chainId2, contractInterface, functionName, overrides]);
  const enabled = React11.useMemo(() => {
    let enabled2 = Boolean(enabled_ && addressOrName && functionName);
    if (cacheOnBlock)
      enabled2 = Boolean(enabled2 && blockNumber);
    return enabled2;
  }, [addressOrName, blockNumber, cacheOnBlock, enabled_, functionName]);
  useInvalidateOnBlock({
    enabled: watch && !cacheOnBlock,
    queryKey: queryKey_
  });
  return useQuery2(queryKey_, queryFn$7, {
    cacheTime,
    enabled,
    isDataEqual,
    queryKeyHashFn: queryKeyHashFn$1,
    select: (data) => {
      const result = parseContractResult({
        contractInterface,
        data,
        functionName
      });
      return select ? select(result) : result;
    },
    staleTime,
    suspense,
    onError,
    onSettled,
    onSuccess
  });
}
var queryKey$6 = (_ref) => {
  let [{
    allowFailure,
    contracts,
    overrides
  }, {
    blockNumber,
    chainId: chainId2
  }] = _ref;
  return [{
    entity: "readContracts",
    allowFailure,
    blockNumber,
    chainId: chainId2,
    contracts,
    overrides
  }];
};
var queryKeyHashFn = (_ref2) => {
  let [queryKey_] = _ref2;
  const {
    contracts,
    ...rest
  } = queryKey_;
  const contracts_ = contracts === null || contracts === void 0 ? void 0 : contracts.map((contract) => {
    const {
      contractInterface,
      ...rest2
    } = contract;
    return rest2;
  });
  return hashQueryKey([{
    contracts: contracts_,
    ...rest
  }]);
};
var queryFn$6 = (_ref3) => {
  let {
    queryKey: [{
      allowFailure,
      contracts,
      overrides
    }]
  } = _ref3;
  return readContracts({
    allowFailure,
    contracts,
    overrides
  });
};
function useContractReads(_ref4) {
  let {
    allowFailure = true,
    cacheOnBlock = false,
    cacheTime,
    contracts,
    overrides,
    enabled: enabled_ = true,
    isDataEqual = deepEqual,
    keepPreviousData,
    onError,
    onSettled,
    onSuccess,
    select,
    staleTime,
    suspense,
    watch
  } = _ref4;
  const {
    data: blockNumber
  } = useBlockNumber({
    enabled: watch || cacheOnBlock,
    watch
  });
  const chainId2 = useChainId();
  const queryKey_ = React11.useMemo(() => queryKey$6([{
    allowFailure,
    contracts,
    overrides
  }, {
    blockNumber: cacheOnBlock ? blockNumber : void 0,
    chainId: chainId2
  }]), [allowFailure, blockNumber, cacheOnBlock, chainId2, contracts, overrides]);
  const enabled = React11.useMemo(() => {
    let enabled2 = Boolean(enabled_ && contracts.length > 0);
    if (cacheOnBlock)
      enabled2 = Boolean(enabled2 && blockNumber);
    return enabled2;
  }, [blockNumber, cacheOnBlock, contracts, enabled_]);
  useInvalidateOnBlock({
    enabled: watch && !cacheOnBlock,
    queryKey: queryKey_
  });
  return useQuery2(queryKey_, queryFn$6, {
    cacheTime,
    enabled,
    isDataEqual,
    keepPreviousData,
    queryKeyHashFn,
    staleTime,
    select: (data) => {
      const result = data.map((data2, i) => {
        var _contracts$i, _contracts$i2;
        return contracts[i] ? parseContractResult({
          contractInterface: (_contracts$i = contracts[i]) === null || _contracts$i === void 0 ? void 0 : _contracts$i.contractInterface,
          functionName: (_contracts$i2 = contracts[i]) === null || _contracts$i2 === void 0 ? void 0 : _contracts$i2.functionName,
          data: data2
        }) : data2;
      });
      return select ? select(result) : result;
    },
    suspense,
    onError,
    onSettled,
    onSuccess
  });
}
var mutationKey$1 = (_ref) => {
  let [{
    addressOrName,
    args,
    chainId: chainId2,
    contractInterface,
    overrides
  }] = _ref;
  return [{
    entity: "writeContract",
    addressOrName,
    args,
    chainId: chainId2,
    contractInterface,
    overrides
  }];
};
function useContractWrite(_ref2) {
  let {
    addressOrName,
    args,
    chainId: chainId2,
    contractInterface,
    functionName,
    overrides,
    signerOrProvider,
    onError,
    onMutate,
    onSettled,
    onSuccess
  } = _ref2;
  const {
    data,
    error,
    isError: isError2,
    isIdle,
    isLoading,
    isSuccess,
    mutate,
    mutateAsync,
    reset,
    status,
    variables
  } = useMutation(mutationKey$1([{
    addressOrName,
    args,
    chainId: chainId2,
    contractInterface,
    functionName,
    overrides
  }]), (_ref3) => {
    let {
      args: args2,
      overrides: overrides2
    } = _ref3;
    return writeContract({
      addressOrName,
      args: args2,
      chainId: chainId2,
      contractInterface,
      functionName,
      overrides: overrides2,
      signerOrProvider
    });
  }, {
    onError,
    onMutate,
    onSettled,
    onSuccess
  });
  const write = React11.useCallback((overrideConfig) => mutate({
    addressOrName,
    chainId: chainId2,
    contractInterface,
    functionName,
    signerOrProvider,
    ...overrideConfig || {
      args,
      overrides
    }
  }), [addressOrName, args, chainId2, contractInterface, functionName, mutate, overrides, signerOrProvider]);
  const writeAsync = React11.useCallback((overrideConfig) => mutateAsync({
    addressOrName,
    chainId: chainId2,
    contractInterface,
    functionName,
    signerOrProvider,
    ...overrideConfig || {
      args,
      overrides
    }
  }), [addressOrName, args, chainId2, contractInterface, functionName, mutateAsync, overrides, signerOrProvider]);
  return {
    data,
    error,
    isError: isError2,
    isIdle,
    isLoading,
    isSuccess,
    reset,
    status,
    variables,
    write,
    writeAsync
  };
}
var queryKey$5 = (_ref) => {
  let {
    address,
    chainId: chainId2,
    formatUnits: formatUnits2
  } = _ref;
  return [{
    entity: "token",
    address,
    chainId: chainId2,
    formatUnits: formatUnits2
  }];
};
var queryFn$5 = (_ref2) => {
  let {
    queryKey: [{
      address,
      chainId: chainId2,
      formatUnits: formatUnits2
    }]
  } = _ref2;
  if (!address)
    throw new Error("address is required");
  return fetchToken({
    address,
    chainId: chainId2,
    formatUnits: formatUnits2
  });
};
function useToken() {
  let {
    address,
    chainId: chainId_,
    formatUnits: formatUnits2 = "ether",
    cacheTime,
    enabled = true,
    staleTime = 1e3 * 60 * 60 * 24,
    suspense,
    onError,
    onSettled,
    onSuccess
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const chainId2 = useChainId({
    chainId: chainId_
  });
  return useQuery2(queryKey$5({
    address,
    chainId: chainId2,
    formatUnits: formatUnits2
  }), queryFn$5, {
    cacheTime,
    enabled: Boolean(enabled && address),
    staleTime,
    suspense,
    onError,
    onSettled,
    onSuccess
  });
}
var queryKey$4 = (_ref) => {
  let {
    chainId: chainId2,
    name
  } = _ref;
  return [{
    entity: "ensAddress",
    chainId: chainId2,
    name
  }];
};
var queryFn$4 = (_ref2) => {
  let {
    queryKey: [{
      chainId: chainId2,
      name
    }]
  } = _ref2;
  if (!name)
    throw new Error("name is required");
  return fetchEnsAddress({
    chainId: chainId2,
    name
  });
};
function useEnsAddress() {
  let {
    cacheTime,
    chainId: chainId_,
    enabled = true,
    name,
    staleTime = 1e3 * 60 * 60 * 24,
    suspense,
    onError,
    onSettled,
    onSuccess
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const chainId2 = useChainId({
    chainId: chainId_
  });
  return useQuery2(queryKey$4({
    chainId: chainId2,
    name
  }), queryFn$4, {
    cacheTime,
    enabled: Boolean(enabled && chainId2 && name),
    staleTime,
    suspense,
    onError,
    onSettled,
    onSuccess
  });
}
var queryKey$3 = (_ref) => {
  let {
    addressOrName,
    chainId: chainId2
  } = _ref;
  return [{
    entity: "ensAvatar",
    addressOrName,
    chainId: chainId2
  }];
};
var queryFn$3 = (_ref2) => {
  let {
    queryKey: [{
      addressOrName,
      chainId: chainId2
    }]
  } = _ref2;
  if (!addressOrName)
    throw new Error("addressOrName is required");
  return fetchEnsAvatar({
    addressOrName,
    chainId: chainId2
  });
};
function useEnsAvatar() {
  let {
    addressOrName,
    cacheTime,
    chainId: chainId_,
    enabled = true,
    staleTime = 1e3 * 60 * 60 * 24,
    suspense,
    onError,
    onSettled,
    onSuccess
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const chainId2 = useChainId({
    chainId: chainId_
  });
  return useQuery2(queryKey$3({
    addressOrName,
    chainId: chainId2
  }), queryFn$3, {
    cacheTime,
    enabled: Boolean(enabled && addressOrName && chainId2),
    staleTime,
    suspense,
    onError,
    onSettled,
    onSuccess
  });
}
var queryKey$2 = (_ref) => {
  let {
    address,
    chainId: chainId2
  } = _ref;
  return [{
    entity: "ensName",
    address,
    chainId: chainId2
  }];
};
var queryFn$2 = (_ref2) => {
  let {
    queryKey: [{
      address,
      chainId: chainId2
    }]
  } = _ref2;
  if (!address)
    throw new Error("address is required");
  return fetchEnsName({
    address,
    chainId: chainId2
  });
};
function useEnsName() {
  let {
    address,
    cacheTime,
    chainId: chainId_,
    enabled = true,
    staleTime = 1e3 * 60 * 60 * 24,
    suspense,
    onError,
    onSettled,
    onSuccess
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const chainId2 = useChainId({
    chainId: chainId_
  });
  return useQuery2(queryKey$2({
    address,
    chainId: chainId2
  }), queryFn$2, {
    cacheTime,
    enabled: Boolean(enabled && address && chainId2),
    staleTime,
    suspense,
    onError,
    onSettled,
    onSuccess
  });
}
var queryKey$1 = (_ref) => {
  let {
    chainId: chainId2,
    name
  } = _ref;
  return [{
    entity: "ensResolver",
    chainId: chainId2,
    name
  }];
};
var queryFn$1 = (_ref2) => {
  let {
    queryKey: [{
      chainId: chainId2,
      name
    }]
  } = _ref2;
  if (!name)
    throw new Error("name is required");
  return fetchEnsResolver({
    chainId: chainId2,
    name
  });
};
function useEnsResolver() {
  let {
    cacheTime,
    chainId: chainId_,
    enabled = true,
    name,
    staleTime = 1e3 * 60 * 60 * 24,
    suspense,
    onError,
    onSettled,
    onSuccess
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const chainId2 = useChainId({
    chainId: chainId_
  });
  return useQuery2(queryKey$1({
    chainId: chainId2,
    name
  }), queryFn$1, {
    cacheTime,
    enabled: Boolean(enabled && chainId2 && name),
    staleTime,
    suspense,
    onError,
    onSettled,
    onSuccess
  });
}
var mutationKey = (args) => [{
  entity: "sendTransaction",
  ...args
}];
var mutationFn = (args) => {
  const {
    chainId: chainId2,
    request
  } = args;
  if (!request)
    throw new Error("request is required");
  return sendTransaction({
    chainId: chainId2,
    request
  });
};
function useSendTransaction() {
  let {
    chainId: chainId2,
    request,
    onError,
    onMutate,
    onSettled,
    onSuccess
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    data,
    error,
    isError: isError2,
    isIdle,
    isLoading,
    isSuccess,
    mutate,
    mutateAsync,
    reset,
    status,
    variables
  } = useMutation(mutationKey({
    chainId: chainId2,
    request
  }), mutationFn, {
    onError,
    onMutate,
    onSettled,
    onSuccess
  });
  const sendTransaction2 = React11.useCallback((args) => mutate({
    chainId: chainId2,
    request,
    ...args !== null && args !== void 0 ? args : {}
  }), [chainId2, mutate, request]);
  const sendTransactionAsync = React11.useCallback((args) => mutateAsync({
    chainId: chainId2,
    request,
    ...args !== null && args !== void 0 ? args : {}
  }), [chainId2, mutateAsync, request]);
  return {
    data,
    error,
    isError: isError2,
    isIdle,
    isLoading,
    isSuccess,
    reset,
    sendTransaction: sendTransaction2,
    sendTransactionAsync,
    status,
    variables
  };
}
var queryKey = (_ref) => {
  let {
    confirmations,
    chainId: chainId2,
    hash,
    timeout,
    wait
  } = _ref;
  return [{
    entity: "waitForTransaction",
    confirmations,
    chainId: chainId2,
    hash,
    timeout,
    wait
  }];
};
var queryFn = (_ref2) => {
  let {
    queryKey: [{
      chainId: chainId2,
      confirmations,
      hash,
      timeout,
      wait
    }]
  } = _ref2;
  return waitForTransaction({
    chainId: chainId2,
    confirmations,
    hash,
    timeout,
    wait
  });
};
function useWaitForTransaction() {
  let {
    chainId: chainId_,
    confirmations,
    hash,
    timeout,
    wait,
    cacheTime,
    enabled = true,
    staleTime,
    suspense,
    onError,
    onSettled,
    onSuccess
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const chainId2 = useChainId({
    chainId: chainId_
  });
  return useQuery2(queryKey({
    chainId: chainId2,
    confirmations,
    hash,
    timeout,
    wait
  }), queryFn, {
    cacheTime,
    enabled: Boolean(enabled && (hash || wait)),
    staleTime,
    suspense,
    onError,
    onSettled,
    onSuccess
  });
}

export {
  alchemyRpcUrls,
  infuraRpcUrls,
  publicRpcUrls,
  etherscanBlockExplorers,
  chainId,
  chain,
  allChains,
  defaultChains,
  defaultL2Chains,
  _classPrivateMethodInitSpec,
  _classPrivateFieldInitSpec,
  _defineProperty,
  _classPrivateFieldGet,
  _classPrivateMethodGet,
  _classPrivateFieldSet,
  normalizeChainId,
  RpcError,
  ProviderRpcError,
  AddChainError,
  ChainDoesNotSupportMulticallError,
  ChainMismatchError,
  ChainNotConfiguredError,
  ConnectorAlreadyConnectedError,
  ConnectorNotFoundError,
  ContractMethodNoResultError,
  ProviderChainsNotFound,
  ResourceUnavailableError,
  SwitchChainError,
  SwitchChainNotSupportedError,
  UserRejectedRequestError,
  Connector,
  require_utils,
  shimDisconnectKey,
  InjectedConnector,
  createStorage,
  Client,
  getClient,
  configureChains,
  deepEqual,
  erc20ABI,
  erc721ABI,
  readContracts,
  deserialize,
  serialize,
  createClient2 as createClient,
  Context,
  WagmiConfig,
  useClient,
  useInfiniteQuery2 as useInfiniteQuery,
  useQuery2 as useQuery,
  useProvider,
  useWebSocketProvider,
  useBlockNumber,
  useFeeData,
  useAccount,
  useBalance,
  useConnect,
  useDisconnect,
  useNetwork,
  useSigner,
  useSignMessage,
  useSignTypedData,
  useSwitchNetwork,
  useContract,
  useContractEvent,
  paginatedIndexesConfig,
  useContractInfiniteReads,
  useContractRead,
  useContractReads,
  useContractWrite,
  useToken,
  useEnsAddress,
  useEnsAvatar,
  useEnsName,
  useEnsResolver,
  useSendTransaction,
  useWaitForTransaction
};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=chunk-EKNMFKRH.js.map
